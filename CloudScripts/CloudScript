/// NOTE: methods that start with handlers.(methodName) are methods accessible from the client.
/// All other methods are for the SERVER only!!! Do not change these lightly.
/// This file is clearly enormous. I've tried my best to "extract till I drop" and comment everything.
/// Because there are server API limits (10 per call), a lot of methods require the data structures from
/// the API calls to be passed in, so I don't wind up hitting the API a massive number of times.

/////////////////////////////////////////////////
/// Constants
/// Constants used in methods throughout the
/// cloud script.
/////////////////////////////////////////////////

/// game specific
const UPGRADE_LEVEL = "Level";  // key for a level upgrade
const COEFFICIENT = "Coefficient";
const CLASS = "Class";          // key used from client as to what type of data (building, unit, etc) is involved in the call
const TARGET_ID = "TargetID";   // key used from client as to what specific object is involved in the call
const CHANGE = "Change";        // key used from client to pass up a change

/// starting data
const STARTING_GOLD = 2000;

// unit counting
const LAST_UNIT_COUNT = "LastCountTime";            // key for timestamp of last unit count update (in unit's progress data)
const UNIT_COUNT = "Count";                         // key in unit's save data for # of that unit
const UNIT_BASE_PROGRESS = "BaseProgressPerSecond"; // key in unit's title data for base progress per second
const COUNT_TIME = "Time";                           // for testing unit counting; time to pretend it is

// unit title data
const UNIT_ID = "ID";                               // ID of the unit
const UNIT_STATS = "Stats";                         // stats object on the unit

// unit stats
const STAT_BASE = "Base";                           // key for the base stat on a unit

/// metrics
const GAME_METRICS = "GameMetrics";
const METRICS = "Metrics";
const TOTAL_MISSIONS_DONE = "TotalMissionsCompleted";

// misc -- these are keys many data structures have
const WEIGHT = "Weight";                            // weight of an object
const LEVEL_RESTRICTION = "LevelRestriction";       // level restriction of an object
const MIN = "Min";
const MAX = "Max";
const INDEX = "Index";
const MINIMUM = "Minimum";
const MODIFIES_TYPE = "ModifiesType";
const KEY = "Key";
const AMOUNT = "Amount";
const MODIFICATIONS = "Modifications";
const NAME = "Name";
const DESC = "DescriptionKey";
const ID = "ID";
const WORLD = "World";
const MAP = "Map";

// map related
const DEFAULT_MAP_SIZE = 36;
const NEW_PLAYER_MAP = "NewPlayerMap";                  // title data key for the map data that should be a new player's
const MAP_SAVE_KEY = "Map_";                            // key used in player's save data for defining a type of map
const MAP_WORLD = "World";                              // key in map data structure for the map's world
const MAP_LEVEL = "MapLevel";                           // key in mapa data structure for the map's level
const MAP_SIZE = "MapSize";                             // key for size of the map (int)
const MAP_AREAS = "Areas";                              // key for list/array of areas inside a map
const MAP_UPCOMING = "UpcomingMaps";                    // key for list/array of upcoming maps, from a map
const MAP_ALL_MODS = "AllModifications";                // key for list/array of all modifications on a map
const UPCOMING_MAPS_COUNT = 4;                          // standard # of upcoming maps, from a map
const AREAS_PER_TRAVEL_OPTION = 9;                      // # of area clears per unlocked travel option

// map area types
const AREA_COMBAT = "Combat";       // 0
const AREA_EXPLORE = "Explore";     // 1
const AREA_MISC = "Misc";           // 2

// constants for parsing map modification data in terms of area types
const DEFAULT_MAP_WEIGHTS = "DefaultMapWeights";    // title data field holding the default map weights
const COMBAT_WEIGHT = "CombatWeight";
const COMBAT_MINIMUM = "CombatMinimum";
const COMBAT_INDEX = 0;
const EXPLORE_WEIGHT = "ExploreWeight";
const EXPLORE_MINIMUM = "ExploreMinimum";
const EXPLORE_INDEX = 1;
const MISC_WEIGHT = "MiscWeight";
const MISC_MINIMUM = "MiscMinimum";
const MISC_INDEX = 2;

/// other map mod constants
const MAP_GOLD_MOD = "BaseGoldReward";                  // affects gold earned from a mission

// map area related
const MAP_AREA_TYPE = "AreaType";                       // key holding the type an area is (combat, explore, misc, etc)
const MAP_AREA_MISSION = "Mission";                     // key holding the mission of an area

// map piece related
const MAP_PIECES_TITLE_KEY = "MapPieces_";
const MAP_PREFIX = "Prefix";                            // keys for the 3 parts of a map name that determine its characteristics
const MAP_TERRAIN = "Terrain";
const MAP_SUFFIX = "Suffix";
const MAP_PIECE_ID = "ID";                              // key in map piece data for the piece's ID               

// buildings
const BUILDING_START_SIZE = "StartingSize";         // key for building title data: the building's starting size
const BUILDING_UNIT = "Unit";                       // key for building title data: the building's unit

// currencies
const CURRENCY_GOLD = "G1";

// upgrade related
const UPGRADE_ID = "UpgradeID";                 // key used from client as to what upgradeable on the target is involed in the call
const UPGRADE_RESOURCES = "ResourcesToUpgrade"; // key for finding list of resources that an upgrade requires
const UPGRADE_POINTS = "Points";                // key for a progress data's xp
const UPGRADE_PROGRESS = "Progress";            // key for upgrading an upgradeable by a progress %

// trainer related
const TRAINER_SAVE_DATA = "TrainerSaveData";    // key for player's trainer save data
const TRAINER_COUNTS = "TrainerCounts";         // key for trainer counts within the trainer save data object
const NORMAL_TRAINER = "Normal";                // the normal trainers a player can purchase
const TRAINERS_ASSIGNED = "Trainers";           // key in unit progress data for the # of trainers assigned to the unit
const BASE_TRAINER_COST = 500;                 // base gold cost for a trainer
const TRAINER_UPGRADE_COEFFICIENT = 1.12;

// World progress
const WORLD_PROGRESS_KEY = "WorldsProgress";
const WORLD_PROGRESS_RESTARTS = "RestartCount";
const WORLD_PROGRESS_CUR_MAP = "CurrentMapLevel";

/// unlock data related
const UNIT_UNLOCK_PLAN = "UnitUnlockPlan";      // title data
const UNLOCKS = "Unlocks";
const UNLOCK_UNIT_ID = "UnitID";
const UNLOCK_BUILDING_ID = "BuildingID";


/// game modules
const MODULE_BASE = "Base";    // the base game!

/// modifiers
const UNIT_MODIFICATIONS = "UnitModifications"; // key to get at unit modification data in a unit modifier
const MODIFIER_UNITS = "UnitsModified";      // key on a modifier containing the list of units modified
const MODIFIER_STAT = "StatModified";           // key on a modifier containing the stat it modifies
const MODIFIER_TYPE = "ModifierType";           // key on a modifier containing the type of modification (percent, flat, etc)
const MODIFIER_BASE = "BaseModifier";           // key on modifier holding the base amount it modifies by
const MODIFIER_ALL = "All";                     // value meaning all things are modified (stats, or units)

/// modifier enums
const MODIFIER_FLAT = 0;        // flat bonus
const MODIFIER_PERCENT = 1;     // percentage bonus

/// missions
const MISSION_PROGRESS_KEY = "MissionProgress"; // player save data for mission progress
const MISSION_TYPE_KEY = "MissionCategory";     // the key holding the mission type of the mission or complete call
const MISSION_SAVE_KEY = "Missions_";           // the save key that all missions are saved with in internal data, i.e. Key_(type)
const MISSION_INDEX_KEY = "Index";              // used when specifying a particular mission within a type
const MISSION_PROPOSALS_KEY = "TaskProposals"; // key for the client to send task proposals for a mission
const MISSION_TASKS_KEY = "Tasks";              // in mission data; object that holds the tasks for the mission
const MISSION_PROPOSAL_UNIT = "UnitID";         // key in task proposal holding the unit id
const MISSION_PROPOSAL_COUNT = "UnitCount";     // key in task proposal holding # of units proposed
const MISSION_REQUIRED_STAT = "StatRequirement";    // key in a mission task holding the required stat
const MISSION_REQUIRED_POWER = "PowerRequirement";  // key in a mission task holing the required power
const MISSION_BASE_TITLE_KEY = "MissionBase_"   // key for title data that holds the basis for missions of a type (combat, explore, etc)
const MISSION_GOLD_REWARD = "GoldReward";
const MISSION_TASK_BASE_POWER = 10;             // for alpha; determines how much power a mission task requires. scales with map level.

/// mission constants
const BASE_GOLD_REWARD = 100;
const GOLD_REWARD_COEFFICIENT = 1.09;

/// mission progress
const MISSION_PROGRESS_LIST = "Missions";
const MISSION_PROGRESS_DONE = "Completed";

/// classes of objects in the game
const CLASS_BUILDING = "Buildings";     // game buildings that produce units
const CLASS_UNIT = "Units";             // units that are apart of buildings
const CLASS_GUILD = "Guilds";           // guilds that augment units and other things

// data in an upgrade
const MAX_LEVEL = "MaxLevel";               // highest level upgrade can be set to
const BASE_XP_TO_LEVEL = "BaseXpToLevel";   // base amount of xp required to upgrade 

/// testing
const SAVE_KEY = "SaveKey";             // for accessing some save data
const DATA_ACCESS = "DataAccess";       // for specifying internal, read only, etc

/// API specific
const VIRTUAL_CURRENCY = "VirtualCurrency"; // API key for virtual currency
const DATA = "Data";                        // API key for accessing data after getting the save data
const VALUE = "Value";                      // API key for accessing the actual data value after getting the save data


/////////////////////////////////////////////////
/// ~Constants
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Testing
/// These methods should all check that the
/// account is a testing account with isTesting().
/// These methods exist to edit save data and
/// currency in preperation for running very
/// specific integration tests.
/////////////////////////////////////////////////

/// Checks to see if the account is marked for testing.
function isTesting() {
    var internalData = server.GetUserInternalData({ PlayFabId: currentPlayerId, Keys: ["Testing"] });    
    var data = internalData[DATA];    
    var isTesting = false;

    if (data.hasOwnProperty("Testing")) {
        var value = data["Testing"];
        isTesting = value[VALUE] == "true";
    }
    
    log.info("Account Test Status: " + isTesting);

    return isTesting;
}

/// Test for purposefully going over the cloudscript limit to see what happens
handlers.overLimit = function (args) {
    if (!isTesting()) {
         return { outOfSync : true };;    
    }

    var one = isTesting();
    var two = isTesting();
    var three = isTesting();
    var four = isTesting();
    var five = isTesting();
    var six = isTesting();
    var seven = isTesting();
    var eight = isTesting();
    var nine = isTesting();
    var ten = isTesting();
    var eleven = isTesting();
    var twelve = isTesting();
}

/// Test adding points to an upgrade
handlers.addPointsToUpgrade = function (args) {
    if (!isTesting()) {
         return returnOutOfSync();  
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var upgradeID = args.data[UPGRADE_ID];
    var pointsToAdd = GetNumberFromArgs(args, UPGRADE_POINTS);

    AddPointsToUpgradeParent(className, targetID, upgradeID, pointsToAdd, args);
}

/// Test adding progress to an update
handlers.addProgressToUpgrade = function(args) {
    if (!isTesting()) {
         return returnOutOfSync();  
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var upgradeID = args.data[UPGRADE_ID];
    var totalProgressToAdd = GetFloatFromArgs(args, UPGRADE_PROGRESS);

    AddProgressToUpgrade(className, targetID, upgradeID, totalProgressToAdd, args);
}

/// Gets the test missions, used when I was creating the mission format
handlers.getTestMissions = function (args) {
    if (!isTesting()) {
         return returnOutOfSync();  
    }

   var missionType = args.data[MISSION_TYPE_KEY];

   var missions = GetMissionsOfType(missionType);

   return ReturnDataToClient(missions);
}

/// use this method to test if unit counts are updating properly
handlers.testUpdateUnitCount = function (args) {
    if (!isTesting()) {
         return returnOutOfSync();  
    }

    var time = GetNumberFromArgs(args, COUNT_TIME);
    UpdateAllUnitCounts(time);
}

/// use this method if you want to upgrade an upgradeable, bypassing all other normal checks
handlers.testUpgrade = function (args) {
    if (!isTesting()) {
         return returnOutOfSync();    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var allProgressData = GetProgressData(className);
    var progressForTarget = GetProgressForTarget(allProgressData, targetID);    

    UpgradeAndSave(allProgressData, className, progressForTarget, targetID);
}

/// use this method if you want to train a unit, bypassing all other normal checks
handlers.testChangeTraining = function (args) {
    if (!isTesting()) {
         return returnOutOfSync();    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var changeInTrainers = GetNumberFromArgs(args, CHANGE);
    var allProgressData = GetProgressData(className);
    var progressForTarget = GetProgressForTarget(allProgressData, targetID);

    ChangeTrainingLevel(allProgressData, progressForTarget, changeInTrainers, targetID, className);
}

/// returns the capacity for a unit
handlers.getCapacityForUnit = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var unitKey = args.data[TARGET_ID];
    var allBuildingProgress = GetProgressData(CLASS_BUILDING);
    var allBuildingData = GetTitleDataForClass(CLASS_BUILDING);

    var capacity = GetCapacityForUnit(unitKey, allBuildingProgress, allBuildingData);
    return ReturnDataToClient(capacity);
}

/// returns max level for upgrade
handlers.getMaxLevelForUpgrade = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }    

    var className = args.data[CLASS];
    var upgradeID = args.data[UPGRADE_ID];
    var targetID = args.data[TARGET_ID];

    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var maxLevel = GetUpgradeDataMaxLevel(upgradeData);

    return ReturnDataToClient(maxLevel);
}

/// returns the total amount of xp required to upgrade the target upgradeable
handlers.getTotalPointsToUpgrade = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }    

    var className = args.data[CLASS];
    var upgradeID = args.data[UPGRADE_ID];
    var targetID = args.data[TARGET_ID];

    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var allProgressDataForClass = GetProgressData(className);
    var progressDataForTarget = GetProgressForTarget(allProgressDataForClass, targetID);

    var points = GetTotalPointsForNextLevel(progressDataForTarget, upgradeData);
    return ReturnDataToClient(points);
}

/// returns the elapsed time needed to train the unit to the desired number
handlers.getTrainTimeForUnit = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var unitKey = args.data[TARGET_ID];
    var change = GetNumberFromArgs(args, CHANGE);

    var allUnitProgress = GetProgressData(CLASS_UNIT);
    var allUnitData = GetTitleDataForClass(CLASS_UNIT);

    var unitSaveData = allUnitProgress[unitKey];
    var unitTitleData = allUnitData[unitKey];    

    var progressPerSecond = GetUnitProgressPerSecond(unitSaveData, unitTitleData);
    var elapsedTime = (change / progressPerSecond) * 1000;

    return ReturnDataToClient(elapsedTime);
}

/// returns the # of units the player currently has
handlers.getUnitCount = function (args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var readOnlyData = GetProgressData(CLASS_UNIT);
    var targetID = args.data[TARGET_ID];    
    var progressData = GetProgressForTarget(readOnlyData, targetID);

    var count = GetUnitCount(progressData);
    return ReturnDataToClient(count);
}

/// returns the progress data for a specific class and ID.
/// Used to check that a very specific portion of data changed.
handlers.getProgressData = function (args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];

    var readOnlyData = GetProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);
        
    return ReturnDataToClient(progressData);    
}

/// returns the normal trainer count of the player
handlers.getTrainerCount = function (args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var normalTrainers = trainerCounts[NORMAL_TRAINER];

    return ReturnDataToClient(normalTrainers);
}

/// for getting at internal data
handlers.getInternalData = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var key = args.data[SAVE_KEY];
    var value = GetInternalSaveData(key);   
    
    return ReturnDataToClient(value);
}

/// for getting read only data
handlers.getReadOnlyData = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var key = args.data[SAVE_KEY];
    var value = GetReadOnlySaveData(key); 
    
    return ReturnDataToClient(value);
}

/// returns the # of available trainers
handlers.getAvailableTrainers = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var allProgressData = GetProgressData(CLASS_UNIT);
    var availableTrainers = GetAvailableTrainers(allProgressData);

    return ReturnDataToClient(availableTrainers);
}

/// sets player data of a key to a value
handlers.setSaveData = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    var key = args.data["Key"];
    var value = args.data[VALUE];
    var access = args.data[DATA_ACCESS];

    SetSaveData(key, value, access);
}

/// convenience function that turns some raw data into a json string to send back to client
function ReturnDataToClient(rawData) {
    if (!isTesting()) {
        return returnOutOfSync();    
    }

    var dataToString = JSON.stringify(rawData);
    log.info("Returning test data to client: " + dataToString);

    var data = { data : dataToString }
    return data;
}

/// sets a type of the player's currency to a value.
/// this has to be done by adding or subtracting the difference of
/// the incoming value depending on the player's current currency,
/// because there is no API call to set a currency to a specific value.
handlers.setPlayerCurrency = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }    

    var amountToSet = args.data["Amount"];
    var currencyType = args.data["Type"];

    SetCurrency(currencyType, amountToSet);
}

handlers.getPlayerCurrency = function(args) {
        if (!isTesting()) {
        return returnOutOfSync();
    }

    var currencyType = args.data["Type"];
    var playerInventory = GetPlayerInventory();   

    var amount = GetAmountOfCurrency(playerInventory, currencyType);

    return ReturnDataToClient(amount);
}

/// for testing the creation of a map
handlers.createMapForTesting = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    SetAllPieceData_Global();

    var mapLevel = GetNumberFromArgs(args, MAP_LEVEL);  
    var mapWorld = args.data[MAP_WORLD];
    var mapSize = GetNumberFromArgs(args, MAP_SIZE);
    var mapName = GenerateMapName(mapLevel);

    var map = CreateMap(mapName, mapWorld, mapLevel, mapSize);

    return ReturnDataToClient(map);
}

/// test function used to get some title data
handlers.getDefaultMapAreaWeights = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    var defaultWeights = GetTitleData(DEFAULT_MAP_WEIGHTS);

    return ReturnDataToClient(defaultWeights);
}

/// for tests where the players save data needs to be wiped
handlers.deleteAllPlayerReadOnlyData = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }    

    var emptyData = {};
    emptyData[GetProgressKey(CLASS_BUILDING)] = "{}";
    emptyData[GetProgressKey(CLASS_UNIT)] = "{}";
    emptyData[GetProgressKey(CLASS_GUILD)] = "{}";
    emptyData[TRAINER_SAVE_DATA] = "{}";
    emptyData[WORLD_PROGRESS_KEY] = "{}";
    emptyData[MAP_SAVE_KEY + MODULE_BASE] = "{}";
    emptyData[MISSION_PROGRESS_KEY] = "{}";
    emptyData[GAME_METRICS] = "{}";

    SetSaveDataWithObject(emptyData, READ_ONLY);

    SetCurrency(CURRENCY_GOLD, 0);
}

/// for testing adding missing player data
handlers.addMissingPlayerData = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    AddMissingPlayerData();    
}

handlers.getAllPlayerReadOnlySaveData = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    var allSaveData = GetAllReadOnlySaveData();

    return ReturnDataToClient(allSaveData);
}

handlers.getTitleData = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    var key = args.data[SAVE_KEY];
    var titleData= GetTitleData(key);

    return ReturnDataToClient(titleData);
}

handlers.getGameMetric = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    var metricName = args.data[KEY];

    return ReturnDataToClient(GetGameMetric(metricName));
}

handlers.unitUnlockCheck = function(args) {
    if (!isTesting()) {
        return returnOutOfSync();
    }

    CheckForUnitUnlock();
}

/////////////////////////////////////////////////
/// ~Testing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Map Utils
/////////////////////////////////////////////////

function GetMapOfWorld(world) {
    var key = GetMapSaveKey(world);
    return GetReadOnlySaveData(key);
}

function GetMissionFromMap(map, missionIndex) {
    var areas = GetMapAreas(map);
    var areaForMission = areas[missionIndex];
    return GetMissionFromArea(areaForMission);
}

/////////////////////////////////////////////////
/// ~Map Utils
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Map Data
/////////////////////////////////////////////////

function GetMapLevel(map) {
    return map[MAP_LEVEL];
}

function GetMapSize(map) {
    return map[MAP_SIZE];
}

function GetMapWorld(map) {
    return map[MAP_WORLD];
}

function GetMapAreas(map) {
    return map[MAP_AREAS];
}

function GetMissionFromArea(area) {
    return area[MAP_AREA_MISSION];
}

function GetUpcomingMapCount() {
    return UPCOMING_MAPS_COUNT;
}

function GetUpcomingMaps(map) {
    return map[MAP_UPCOMING];
}

function GetAllMapModifications(map) {
    return map[MAP_ALL_MODS];
}

function GetMapModificationAmount(map, key) {
    var allMapMods = GetAllMapModifications(map);
    for (var index in allMapMods) {
        var mod = allMapMods[index];
        if (mod[KEY] == key) {
            return mod[AMOUNT];
        }
    }

    return 0;
}

function GetMapSaveKey(world) {
    return MAP_SAVE_KEY + world;
}

function GetUpcomingMapNameFromMap(currentMap, index) {
    var upcomingMaps = GetUpcomingMaps(currentMap);

    if (index < 0 || index > upcomingMaps.length+1) {
        log.info("ERROR: Illegal upcoming map get: " + index);
        index = 0;
    }

    return upcomingMaps[index];
}

/////////////////////////////////////////////////
/// ~Map Data
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// TravelTo
/////////////////////////////////////////////////

handlers.initiateTravelTo = function (args) { 
    var optionIndex = GetNumberFromArgs(args, INDEX);
    var world = args.data[WORLD];

    log.info("Attempting to travel to " + optionIndex);

    if (CanTravelToUpcomingMapIndex(optionIndex, world)) {
        TravelToIndex(optionIndex, world);
        return ReturnNewAreaData(world);
    } else {
        return { outOfSync : true };
    }
}

function ReturnNewAreaData(world) {
    RefreshMissionProgressGlobal();
    
    var newMap = GetMapOfWorld(world);
    var mapAsString = JSON.stringify(newMap);

    var progress = GetMissionProgressForWorld(world);
    var progressAsString = JSON.stringify(progress);

    var data = {};
    data[MAP] = mapAsString;
    data[MISSION_PROGRESS_KEY] = progressAsString;
    return data;
}

function CanTravelToUpcomingMapIndex(optionIndex, world) {    
    var clearedAreaCount = GetClearedMissionsForWorld(world);
    var areasRequiredForIndex = GetClearedAreasRequiredForTravelOptionIndex(optionIndex);

    log.info("Checking if can travel to upcoming map index, cleared count is " + clearedAreaCount + " and required is " + areasRequiredForIndex);
    return clearedAreaCount >= areasRequiredForIndex;
}

function GetClearedAreasRequiredForTravelOptionIndex(optionIndex) {
    var requiredClears = AREAS_PER_TRAVEL_OPTION * (optionIndex+1);
    return requiredClears;
}

function TravelToIndex(optionIndex, world) {
    var currentMap = GetMapOfWorld(world);
    var nextMapLevel = GetMapLevel(currentMap) + 1;
    var nextMapName = GetUpcomingMapNameFromMap(currentMap, optionIndex);

    var nextMap = CreateMap(nextMapName, world, nextMapLevel, DEFAULT_MAP_SIZE);    
    CreateMissionProgressForMap(nextMap, false);
    SaveMap(nextMap);    
}

function SaveMap(map) {
    var world = GetMapWorld(map);
    var mapKey = GetMapSaveKey(world);
    SetReadOnlyData(mapKey, map);
}

/////////////////////////////////////////////////
/// ~TravelTo
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Map Globals
/// These kinds of things exist because we can
/// only make so many API calls per cloud call.
/////////////////////////////////////////////////

// sets the map piece data for each piece type, used by various method
var global_allPieces;
function SetAllPieceData_Global() {
    if (global_allPieces == null) {
        global_allPieces = {};
        global_allPieces[MAP_PREFIX] = GetTitleDataForMapPiece(MAP_PREFIX);
        global_allPieces[MAP_TERRAIN] = GetTitleDataForMapPiece(MAP_TERRAIN);
        global_allPieces[MAP_SUFFIX] = GetTitleDataForMapPiece(MAP_SUFFIX);
    }
}

/////////////////////////////////////////////////
/// ~Map Globals
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Map Creation
/////////////////////////////////////////////////

/// Creates a map for the given level and world
function CreateMap(mapName, worldKey, mapLevel, mapSize) {    
    SetAllPieceData_Global();  

    var map = CreateMapObject(worldKey, mapLevel, mapSize);
    var isFirstMap = false;

    SetMapName(map, mapName);
    SetUpcomingMaps(map);
    SetMapAreas(map);
    CreateMissionProgressForMap(map, isFirstMap);

    log.info("Returning map: " + JSON.stringify(map));
    return map;
}

function CreateMapObject(worldKey, mapLevel, mapSize) {
    log.info("Creating a map object with level " + mapLevel + " and world " + worldKey + " and size " + mapSize);

    var map = {};
    map[MAP_WORLD] = worldKey;
    map[MAP_LEVEL] = mapLevel;
    map[MAP_SIZE] = mapSize;

    map[MAP_AREAS] = [];

    return map;
}

function SetMapName(map, mapName) {
    map[NAME] = mapName;
}

function GenerateMapName(mapLevel) {
    var mapName = {};
    mapName[MAP_PREFIX] = GetMapPiece(mapLevel, MAP_PREFIX);
    mapName[MAP_TERRAIN] = GetMapPiece(mapLevel, MAP_TERRAIN);
    mapName[MAP_SUFFIX] = GetMapPiece(mapLevel, MAP_SUFFIX);

    return mapName;
}

function SetUpcomingMaps(map) {
    log.info("Setting upcoming maps");
    var nextMapLevel = GetMapLevel(map) + 1;
    var numUpcomingMaps = GetUpcomingMapCount();

    var upcomingMaps = [];
    for (var i = 0; i < numUpcomingMaps; i++) {
        log.info("Creating a map for upcoming map # " + i + " of " + numUpcomingMaps);
        var potentialMap = GenerateMapName(nextMapLevel);
        upcomingMaps.push(potentialMap);
    }

    map[MAP_UPCOMING] = upcomingMaps;
}

function SetMapAreas(map) {
    //log.info("Setting map areas for " + JSON.stringify(map));

    var indexArray = CreateMapIndexArray(map);
    SetMapModifications(map);
    var areas = map[MAP_AREAS];
    var weightedAreaList = GetWeightedMapAreaList(map);
    var defaultMission = GetTitleData("DefaultMission");

    for (var i = indexArray.length-1; i >= 0; i--) {   
        var index = indexArray[i];
        areas[index] = CreateMapArea(map, index, weightedAreaList, defaultMission);

        indexArray.splice(i, 1);    // remove index from array
    }
}

function SetMapModifications(map) {
    log.info("Getting map area weights");
    
    var allModifications = GetTitleData(DEFAULT_MAP_WEIGHTS);

    var mapNameModifications = GetMapModificationsFromName(map);
    for (var index in mapNameModifications) {        
        AddMapModification(allModifications, mapNameModifications[index]); 
    }

    log.info("All map mods: " + JSON.stringify(allModifications));
    map[MAP_ALL_MODS] = allModifications;
}

function AddMapModification(allModifications, modification) {
    log.info("Modifying area weights from " + JSON.stringify(modification));
    
    var modifierType = modification[KEY];
    var modifierAmount = modification[AMOUNT];

    var found = false;
    for (var index in allModifications) {
        var areaWeight = allModifications[index];
        if (areaWeight[KEY] == modifierType) {
            areaWeight[AMOUNT] += modifierAmount;
            found = true;
        }
    }

    if (!found) {
        allModifications.push(modification);
    }
}

function GetMapModificationsFromName(map) {
    log.info("Getting map modifications from map name");

    var prefixMods = GetMapModificationsFromMapPiece(map, MAP_PREFIX);
    var terrainMods = GetMapModificationsFromMapPiece(map, MAP_TERRAIN);
    var suffixMods = GetMapModificationsFromMapPiece(map, MAP_SUFFIX);

    var allModifications = prefixMods.concat(terrainMods, suffixMods);

    log.info("Total map modifications from map name: " + JSON.stringify(allModifications));

    return allModifications;
}

function GetMapModificationsFromMapPiece(map, pieceKey) {
    var mapName = map[NAME];
    var mapPiece = mapName[pieceKey];
    var mapModifications = mapPiece[MODIFICATIONS];

    return mapModifications;
}

function CreateMapArea(map, areaIndex, weightedAreaList, defaultMission) {
    var area = {};

    area[INDEX] = areaIndex;
    area[MAP_AREA_TYPE] = GenerateMapAreaTypeFromWeights(map, weightedAreaList);
    area[MAP_AREA_MISSION] = GenerateMapMission(map, areaIndex, area[MAP_AREA_TYPE]);
    area[MAP_TERRAIN] = GenerateMapAreaTerrain();

    return area;
}

function GenerateMapMission(map, areaIndex, areaType) {
    var mission = {};

    mission[MISSION_TYPE_KEY] = MODULE_BASE;
    mission[MISSION_INDEX_KEY] = areaIndex;
    mission[MISSION_GOLD_REWARD] = GetMissionGoldReward(map);
    mission[MISSION_TASKS_KEY] = GenerateMissionTasks(map, areaIndex, areaType);

    return mission;
}

/// for alpha, I'm just going to generate one task for each mission
function GenerateMissionTasks(map, areaIndex, areaType) {
    var tasks = [];
    
    var task = {};
    task[MISSION_INDEX_KEY] = 0;
    task[MISSION_REQUIRED_STAT] = GetMissionStat(areaType);
    task[DESC] = GetMissionTaskDescription(task);
    task[MISSION_REQUIRED_POWER] = MISSION_TASK_BASE_POWER * (GetMapLevel(map) + 1);

    tasks.push(task);
    return tasks;
}

function GetMissionTaskDescription(task) {
    var stat = task[MISSION_REQUIRED_STAT];
    var key = stat + "_MISSION_DESC";

    return key;
}

function GetMissionStat(areaType) {
    if (areaType == COMBAT_INDEX) {
        return GetRandomCombatStat();
    } else {
        return GetRandomExploreStat();
    }
}

function GetRandomCombatStat() {
    var stats = ["BASE_STAT_5", "BASE_STAT_6", "BASE_STAT_7", "WIZARD_STAT_1", "PRIEST_STAT_2"];
    return GetRandomArrayElement(stats);
}

function GetRandomExploreStat() {
    var stats = ["BASE_STAT_1", "BASE_STAT_2", "BASE_STAT_3", "BASE_STAT_4"];
    return GetRandomArrayElement(stats);   
}

function GetMissionGoldReward(map) {
    var mapLevel = GetMapLevel(map);
    var coefficient = GOLD_REWARD_COEFFICIENT;
    var goldReward = Math.ceil(BASE_GOLD_REWARD * Math.pow(coefficient, mapLevel-1));
    
    var goldModAmount = GetMapModificationAmount(map, MAP_GOLD_MOD);
    goldReward = goldReward + Math.ceil(goldReward * goldModAmount);

    //log.info("Gold reward: " + goldReward);
    return goldReward;
}

/// this needs to be improved!
function GenerateMapAreaTerrain() {
    var terrains = [ 0, 1, 2 ];
    var selectedTerrain = GetRandomArrayElement(terrains);

    return selectedTerrain;
}

function GenerateMapAreaTypeFromWeights(map, weightedAreaList) {
    var areaWeights = GetAllMapModifications(map);

    if (DoAreaWeightsHaveMinimumRemaining(areaWeights)) {
        return GenerateMapAreaTypeFromMinimum(areaWeights);
    } else {
        return GenerateMapAreaTypeFromWeight(weightedAreaList);
    }
}

function GenerateMapAreaTypeFromMinimum(areaWeights) {
    for (var index in areaWeights) {        
        var areaWeight = areaWeights[index];
        if(IsAreaTypeMinimum(areaWeight)) {
            var minimumRemaining = areaWeight[AMOUNT];
            if (minimumRemaining > 0) {
                var areaType = GetAreaTypeIndexFromWeight(areaWeight);

                areaWeight[AMOUNT] = minimumRemaining - 1;

                return areaType;
            }
        }
    }

    log.info("ERROR: Attempting to generate a minimum from area weights that have no minimum remaining!");
    return 0;
}

function GenerateMapAreaTypeFromWeight(weightedList) {
    var selectedAreaType = GetRandomArrayElement(weightedList);

    return selectedAreaType;
}

function GetWeightedMapAreaList(map) {
    log.info("Generating weighted map area list from " + JSON.stringify(areaWeights));
    var areaWeights = GetAllMapModifications(map);

    var weightedList = [];
    for (var index in areaWeights) {
        var areaWeight = areaWeights[index];
        var isAreaTypeWeight = IsAreaTypeWeight(areaWeight);
        if (isAreaTypeWeight) {
            var weightValue = areaWeight[AMOUNT];
            if (weightValue > 0) {
                var areaType = GetAreaTypeIndexFromWeight(areaWeight);
                for (var i = 0; i < weightValue; i++) {
                    weightedList.push(areaType);
                }            
            }
        }
    }

    log.info("Got weighted area list: " + JSON.stringify(weightedList));
    return weightedList;
}

function IsAreaTypeWeight(areaWeight) {
    var key = areaWeight[KEY];
    return key == COMBAT_WEIGHT || key == MISC_WEIGHT || key == EXPLORE_WEIGHT;
}

function IsAreaTypeMinimum(areaWeight) {
    var key = areaWeight[KEY];
    return key == COMBAT_MINIMUM || key == MISC_MINIMUM || key == EXPLORE_MINIMUM;
}

// this is a crappy function that translates an area type to an index
function GetAreaTypeIndexFromWeight(areaWeight) {
    var key = areaWeight[KEY];
    if (key == COMBAT_WEIGHT || key == COMBAT_MINIMUM) {
        return COMBAT_INDEX;
    } else if (key == EXPLORE_WEIGHT || key == EXPLORE_MINIMUM) {
        return EXPLORE_INDEX;
    } else if (key == MISC_WEIGHT || key == MISC_MINIMUM) {
        return MISC_INDEX;
    } else {
        log.info("Area weight with no area type index: " + key);
        return 0;
    }
}

function DoAreaWeightsHaveMinimumRemaining(areaWeights) {
    for (var index in areaWeights) {        
        //log.info("What's this: " + index);
        var areaWeight = areaWeights[index];

        if (IsAreaTypeMinimum(areaWeight)) {        
            if (areaWeight[AMOUNT] > 0) {
                return true;
            }
        }
    }

    return false;
}

function CreateMapIndexArray(map) {
    log.info("Creating a map index array of size " + map[MAP_SIZE]);

    var indexArray = [];

    for (var i = 0; i < map[MAP_SIZE]; i++) {
        indexArray.push(i);
    }

    ShuffleArray(indexArray);
    return indexArray;
}

function GetMapPiece(level, pieceKey) {  
    var allPieces = global_allPieces[pieceKey];  
    var validPieces = [];

    for (var index in allPieces) {
        var pieceData = allPieces[index];
        //log.info("Processing piece: " + JSON.stringify(pieceData));

        var levelRestriction = GetMapPieceLevelRestriction(pieceData);
        if (DoesPassNumberRestriction(levelRestriction, level)) {
            var weight = GetMapPieceWeight(pieceData);
            //log.info(pieceData[MAP_PIECE_ID] + " is a valid piece, pushing it " + weight + " times");
            for (var i = 0; i < weight; i++) {
                validPieces.push(pieceData);
            }
        }
    }

    var randomPiece = GetRandomArrayElement(validPieces);
    //log.info("Chose map piece: " + randomPiece[MAP_PIECE_ID]);

    return randomPiece;
}

function GetTitleDataForMapPiece(pieceKey) {
    log.info("Getting map piece data for " + pieceKey);

    var titleDataKey = MAP_PIECES_TITLE_KEY + pieceKey;
    var titleData = server.GetTitleData({ Keys : titleDataKey });
    var data = titleData[DATA];
    var allPieceData = data[titleDataKey];

    //log.info("Getting piece data for " + pieceKey + ": " + allPieceData);

    return JSON.parse(allPieceData);
}

function GetMapPieceWeight(pieceData) {
    return pieceData[WEIGHT];
}

function GetMapPieceLevelRestriction(pieceData) {
    return pieceData[LEVEL_RESTRICTION];
}

/// This seems like it's mission related, but it is always set in relation to a map, so I put it with the maps
function CreateMissionProgressForMap(map, isFirstMap) {
    var world = GetMapWorld(map);
    var size = GetMapSize(map);

    var missionProgressSaveData = {};
    if (!isFirstMap) {
        missionProgressSaveData = GetReadOnlySaveData(MISSION_PROGRESS_KEY);
    }
    var missionProgressForMap = CreateMissionProgress(world, size);

    log.info("Setting thing for " + world + ": " + JSON.stringify(missionProgressForMap));
    missionProgressSaveData[world] = missionProgressForMap;

    SetReadOnlyData(MISSION_PROGRESS_KEY, missionProgressSaveData);
}

function CreateMissionProgress(world, mapSize) {
    log.info("Creating mission progress for " + world + " and size " + mapSize);
    var allMissionProgress = {};
    allMissionProgress[WORLD] = world;

    var listOfIndividualMissionProgress = [];
    for (var i = 0; i < mapSize; i++) {
        var individualMissionProgress = {};
        individualMissionProgress[MISSION_PROGRESS_DONE] = false;

        listOfIndividualMissionProgress.push(individualMissionProgress);
    }

    allMissionProgress[MISSION_PROGRESS_LIST] = listOfIndividualMissionProgress;
    return allMissionProgress;

}

/////////////////////////////////////////////////
/// ~Map Creation
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Number Restriction
/////////////////////////////////////////////////

function DoesPassNumberRestriction(restriction, value) {
    var min = restriction[MIN];
    var max = restriction[MAX];

    var passes = value >= min && value <= max;

    return passes;
}


/////////////////////////////////////////////////
/// ~Number Restriction
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Mission Progress
/////////////////////////////////////////////////

var global_allMissionProgress;

function SaveMissionProgress() {
    SetReadOnlyData(MISSION_PROGRESS_KEY, global_allMissionProgress);
}

function GetMissionProgress(world, index) {    
    var missionProgressForWorld = GetMissionProgressForWorld(world);
    var missionProgressList = GetMissionProgressList(missionProgressForWorld);

    return missionProgressList[index];
}

function GetMissionProgressForWorld(world) {
    if (global_allMissionProgress == null) {
        RefreshMissionProgressGlobal();
    }
  
    return global_allMissionProgress[world];
}

function RefreshMissionProgressGlobal() {
    global_allMissionProgress = GetReadOnlySaveData(MISSION_PROGRESS_KEY);
}

function GetClearedMissionsForWorld(world) {
    var missionProgressForWorld = GetMissionProgressForWorld(world);
    var missionProgressList = GetMissionProgressList(missionProgressForWorld);

    var clearedMissions = 0;
    for (var index in missionProgressList) {
        var missionProgress = missionProgressList[index];
        if (IsMissionCompleted(missionProgress)) {
            clearedMissions++;
        }
    }

    return clearedMissions;
}

function IsMissionCompleted(missionProgress) {
    return missionProgress[MISSION_PROGRESS_DONE];
}

function GetMissionProgressList(missionProgressForWorld) {
    return missionProgressForWorld[MISSION_PROGRESS_LIST];
}

/////////////////////////////////////////////////
/// ~Mission Progress
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Missions
/////////////////////////////////////////////////

handlers.initiateCompleteMission = function (args) { 
    UpdateAllUnitCounts(Date.now());

    global_allMissionProgress = null;
       
    var missionType = args.data[MISSION_TYPE_KEY];
    var missionIndex = GetNumberFromArgs(args, MISSION_INDEX_KEY);    
    var taskProposalsJSON = args.data[MISSION_PROPOSALS_KEY];

    var allUnitData = GetTitleDataForClass(CLASS_UNIT);
    var allUnitProgress = GetProgressData(CLASS_UNIT);    

    log.info("Trying to complete mission # " + missionIndex + " for type " + missionType);
    log.info("Trying to complete the mission with proposal: " + taskProposalsJSON);

    var mission = GetMission(missionType, missionIndex);
    var tasks = GetMissionTasks(mission);
    var taskProposals = JSON.parse(taskProposalsJSON);

    if (IsValidMission(missionType, missionIndex) && AreTaskProposalsVerified(tasks, taskProposals, allUnitData, allUnitProgress)) {
        CompleteMission(mission, missionType, taskProposals, allUnitProgress);
    } else {
        return { outOfSync : true };
    }
}

function CompleteMission(mission, missionType, taskProposals, allUnitProgress) {
    log.info("Successfully completed mission: " + GetMissionType(mission) + " #" + GetMissionIndex(mission) );

    MarkMissionComplete(mission, missionType);
    ApplyMissionRewards(mission);
    PayUnitsFromTaskProposals(taskProposals, allUnitProgress);
    CheckForUnitUnlock();
}

function MarkMissionComplete(mission, world) {
    var missionIndex = GetMissionIndex(mission);
    var missionProgress = GetMissionProgress(world, missionIndex);

    missionProgress[MISSION_PROGRESS_DONE] = true;

    SaveMissionProgress();
}

function ApplyMissionRewards(mission) {
    var goldReward = mission[MISSION_GOLD_REWARD];
    AddCurrency(CURRENCY_GOLD, goldReward);
}

function PayUnitsFromTaskProposals(taskProposals, allUnitProgress) {
    log.info("Paying units from task proposals");    

    for(var index in taskProposals) {
        log.info("Processing proposal " + index);
        var proposal = taskProposals[index];
        var unitID = proposal[MISSION_PROPOSAL_UNIT];        
        var unitSaveData = allUnitProgress[unitID];
        var amount = GetNumberFromObject(proposal, MISSION_PROPOSAL_COUNT);

        ChangeUnitCount(unitSaveData, -amount)
    }

    UpdateUnitSaveData(allUnitProgress);
}

function IsValidMission(missionWorld, missionIndex) {
    log.info("Checking mission validity for " + missionWorld + " and " + missionIndex);

    var missionProgress = GetMissionProgress(missionWorld, missionIndex);
    var completed = IsMissionCompleted(missionProgress);

    log.info("Completed: " + completed);

    return !completed;
}

function AreTaskProposalsVerified(tasks, taskProposals, allUnitData, allUnitProgress) {
    log.info("Attempting to verify task proposals");

    if(!HasEnoughProposedUnits(taskProposals, allUnitProgress)) {
        log.info("Proposal failed: not enough units");
        return false;
    }

    var modifiers = GetAllUnitModifiers();

    for(var index in tasks) {
        var task = tasks[index];
        var proposal = taskProposals[index];

        log.info("Checking task index " + index);
        log.info("Task: " + JSON.stringify(task));
        log.info("Proposal: " + JSON.stringify(proposal));

        var proposedUnit = proposal[MISSION_PROPOSAL_UNIT];
        var proposedCount = proposal[MISSION_PROPOSAL_COUNT];
        var unitDataForProposal = allUnitData[proposedUnit];
        var unitProgressForProposal = allUnitProgress[proposedUnit];        

         if(!ProposalMeetsPowerRequirement(unitDataForProposal, unitProgressForProposal, task, proposal, modifiers)) {
            log.info("Proposal failed: not enough power");
            return false;
        }        
    }

    log.info("All proposals verified");
    return true;
}

function HasEnoughProposedUnits(taskProposals, allUnitProgress) {
    log.info("Checking to see if player has proposed units");

    var unitsProposed = GetTotalUnitsProposed(taskProposals);
    for (var proposedUnit in unitsProposed) {
        var count = unitsProposed[proposedUnit];
        log.info("About to ensure that player has " + count + " of " + proposedUnit);

        var unitProgress = allUnitProgress[proposedUnit];
        var hasEnough = HasEnoughUnits(unitProgress, count);

        if (!hasEnough) {
            log.info("Proposed units fails count on " + proposedUnit);
            return false;
        }
    }

    log.info("Proposed units pass count");
    return true;
}

function GetTotalUnitsProposed(taskProposals) {
    var unitsProposed = {};
    for (index in taskProposals) {
        var proposal = taskProposals[index];
        var proposedUnit = proposal[MISSION_PROPOSAL_UNIT];
        var proposedCount = proposal[MISSION_PROPOSAL_COUNT];

        if (unitsProposed.hasOwnProperty(proposedUnit)) {
            var currentCount = unitsProposed[proposedUnit];
            unitsProposed[proposedUnit] = currentCount + proposedCount;
        } else {
            unitsProposed[proposedUnit] = proposedCount;
        }
    }

    return unitsProposed;
}

function ProposalMeetsPowerRequirement(unitDataForProposal, unitProgressForProposal, task, proposal, modifiers) {
    var stat = task[MISSION_REQUIRED_STAT];
    var powerRequirement = task[MISSION_REQUIRED_POWER];
    var unitsRequired = GetNumUnitsForRequirement(unitDataForProposal, unitProgressForProposal, stat, powerRequirement, modifiers);
    var proposedCount = proposal[MISSION_PROPOSAL_COUNT];

    log.info("Checking proposal for stat " + stat + " -- expecting " + unitsRequired + " and proposed " + proposedCount);    

    return proposedCount == unitsRequired;    
}

function GetMissionTasks(mission) {
    log.info("Getting tasks for mission");

    var tasks = mission[MISSION_TASKS_KEY];

    log.info("Got tasks: " + JSON.stringify(tasks));
    return tasks;
}

function GetMission(type, index) {
    log.info("Getting mission " + index + " of type " + type);

    var map = GetMapOfWorld(type);
    var mission = GetMissionFromMap(map, index);

    log.info("Got mission: " + JSON.stringify(mission));
    return mission;
}

function GetMissionsOfType(type) {
    log.info("Getting all missions with type: " + type);
    var saveKey = MISSION_SAVE_KEY + type;

    return GetReadOnlySaveData(saveKey);
}

function GetMissionType(mission) {
    return mission[MISSION_TYPE_KEY];
}

function GetMissionIndex(mission) {
    return mission[MISSION_INDEX_KEY];
}

/////////////////////////////////////////////////
/// ~Missions
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Unlocking
/////////////////////////////////////////////////

function CheckForUnitUnlock() {
    IncrementGameMetric(TOTAL_MISSIONS_DONE);

    var unlock = GetUnlock();
    if (unlock != null) {
        var unitToUnlock = unlock[UNLOCK_UNIT_ID];
        var buildingToUnlock = unlock[UNLOCK_BUILDING_ID]; 
        log.info("Unlocking " + unitToUnlock + " and " + buildingToUnlock);

        UnlockTarget(CLASS_UNIT, unitToUnlock);
        UnlockTarget(CLASS_BUILDING, buildingToUnlock);
    }
}

function GetUnlock() {
    var unlockPlan = GetTitleData(UNIT_UNLOCK_PLAN);    
    var totalMissionsDone = GetGameMetric(TOTAL_MISSIONS_DONE);

    var unlocks = unlockPlan[UNLOCKS];
    var unlock = unlocks[totalMissionsDone];
    return unlock;
}

function UnlockTarget(className, targetID) {
    var allProgressData = GetProgressData(className);
    var progressForTarget = GetProgressForTarget(allProgressData, targetID);
    UpgradeAndSave(allProgressData, className, progressForTarget, targetID);
}

/////////////////////////////////////////////////
/// ~Unlocking
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Metrics
/////////////////////////////////////////////////

function IncrementGameMetric(metricName) {
    var metricsData = GetReadOnlySaveData(GAME_METRICS);
    var allMetrics = metricsData[METRICS];
    allMetrics[metricName] += 1;

    SetReadOnlyData(GAME_METRICS, metricsData);
}

function GetGameMetric(metricName) {
    var metricsData = GetReadOnlySaveData(GAME_METRICS);
    var allMetrics = metricsData[METRICS];
    return allMetrics[metricName];
}

/////////////////////////////////////////////////
/// ~Metrics
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// StatCalculator
/// Used to calculate the stats of a unit.
/////////////////////////////////////////////////

function GetNumUnitsForRequirement(unitData, unitProgress, stat, powerRequirement, modifiers) {
    log.info("Looking for total " + GetUnitID(unitData) + " required for " + stat + " " + powerRequirement);
    var totalUnitsRequired = 0;

    var unitPower = GetTotalStatFromUnit(unitData, unitProgress, stat, modifiers);
    if (unitPower > 0) {
        totalUnitsRequired = Math.ceil(powerRequirement / unitPower);
    } else {
        totalUnitsRequired  = Number.MAX_VALUE;
        log.info("Likely error: " + GetUnitID(unitData) + " did not have " + stat);
    }

    log.info("Total units required: " + totalUnitsRequired);
    return totalUnitsRequired;
}

function GetTotalStatFromUnit(unitData, unitProgress, stat, modifiers) {
    log.info("Getting total " + stat + " for " + GetUnitID(unitData));

    var totalStat = GetTotalBaseStat(unitData, unitProgress, stat);

    for (var modifierType in modifiers) {
        totalStat += GetStatBonusFromModifier(modifiers[modifierType], modifierType, unitData, unitProgress, stat);
    }

    log.info("The total stat of " + stat + " for " + GetUnitID(unitData) + " was " + totalStat);
    return totalStat;
}

function GetStatBonusFromModifier(modifier, modifierType, unitData, unitProgress, stat) {
    if (modifierType == CLASS_GUILD) {
        return GetGuildBonus(modifier, unitData, unitProgress, stat);
    } else {
        log.info("Unhandled unit modifier type: " + modifierType);
        return 0;
    }
}

function GetGuildBonus(modifier, unitData, unitProgress, stat) {
    log.info("Getting guild bonus for " + stat + " on " + GetUnitID(unitData));

    var allGuildData = modifier.data;
    var allGuildProgress = modifier.progress;

    var bonus = 0;
    for (var guildID in allGuildProgress) {
        log.info("Getting bonus for guild " + guildID);

        var guildData = allGuildData[guildID];
        var guildProgress = allGuildProgress[guildID];
        var unitModifications = JSON.parse(guildData[UNIT_MODIFICATIONS]);
        var progressLevel = GetLevelFromProgress(guildProgress);

        bonus += GetModificationBonusForUnit(unitModifications, unitData, unitProgress, stat, progressLevel);
    }

    return Math.ceil(bonus);
}

/////////////////////////////////////////////////
/// ~StatCalculator
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// UnitModification
/////////////////////////////////////////////////

function GetAllUnitModifiers() {
    var guildModifier = {data : GetTitleDataForClass(CLASS_GUILD), progress : GetProgressData(CLASS_GUILD)};

    var modifiers = {};
    modifiers[CLASS_GUILD] = guildModifier;

    return modifiers;
}

function GetModificationBonusForUnit(unitModifications, unitData, unitProgress, stat, progressLevel) {
    var bonus = 0;

    for (var index in unitModifications) {
        var modification = unitModifications[index];
        log.info("Processing modification: " + JSON.stringify(modification));

        bonus += GetBonusFromModification(modification, unitData, unitProgress, stat, progressLevel);
    }

    return bonus;
}

function GetBonusFromModification(modification, unitData, unitProgress, stat, modificationLevel) {
    log.info("Getting bonus from modification for " + GetUnitID(unitData) + " of stat " + stat);
    var bonus = 0;

    if (ModifiesStat(modification, stat) && AffectsUnit(modification, unitData)) {
        bonus = CalculateModificationBonus(modification, unitData, unitProgress, stat, modificationLevel);
    }

    return bonus;
}

function ModifiesStat(modification, stat) {    
    var statModified = modification[MODIFIER_STAT];
    var isModified = statModified == stat || statModified == MODIFIER_ALL;

    log.info("Checking if " + stat + " is modified: " + isModified);
    return isModified;
}

function AffectsUnit(modification, unitData) {
    var unitsModified = modification[MODIFIER_UNITS];
    var indexOfUnit = unitsModified.indexOf(GetUnitID(unitData));
    var indexOfAll = unitsModified.indexOf(MODIFIER_ALL);
    var affectsUnit = indexOfUnit >= 0 || indexOfAll >= 0;

    log.info("Checking if affects " + GetUnitID(unitData) + ": " + affectsUnit);
    return affectsUnit;
}

function CalculateModificationBonus(modifier, unitData, unitProgress, stat, modificationLevel) {
    log.info("Calculating modification bonus");

    var bonus = 0;
    var totalModifier = modifier[MODIFIER_BASE] * modificationLevel;
    var baseStatValue = GetTotalBaseStat(unitData, unitProgress, stat);

    var modifierType = modifier[MODIFIER_TYPE];
    if (modifierType == MODIFIER_FLAT) {
        bonus = totalModifier;
    } else if (modifierType == MODIFIER_PERCENT) {
        bonus = baseStatValue * totalModifier;
    } else {
        log.info("Unhandled modifier type: " + modifierType);
    }

    log.info("Total bonus is: " + bonus);
    return bonus;
}

/////////////////////////////////////////////////
/// ~UnitModification
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Login
/////////////////////////////////////////////////

handlers.onLogin = function (args) {
    AddMissingPlayerData();

    UpdateAllUnitCounts(Date.now());    
}

/// This method looks through all the player's data and makes sure that the default values get added
/// if there were no values there.
function AddMissingPlayerData() {
    var baseMapSaveKey = MAP_SAVE_KEY + MODULE_BASE;
    var saveKeysToCheck = [baseMapSaveKey, GetProgressKey(CLASS_BUILDING), GetProgressKey(CLASS_GUILD), GetProgressKey(CLASS_UNIT), TRAINER_SAVE_DATA, GAME_METRICS];
    var allSaveData = GetMultipleReadOnlySaveData(saveKeysToCheck);

    var arraySaveKeys = [CLASS_BUILDING, CLASS_GUILD, CLASS_UNIT];
    var titleData = GetMultipleTitleData(arraySaveKeys); // iterate through this structure in the method and parse everything

    AddMissingSaveData(allSaveData, arraySaveKeys, titleData);
    StringifySaveData(allSaveData);
    SetSaveDataWithObject(allSaveData, READ_ONLY);
}

function AddMissingSaveData(allSaveData, arraySaveKeys, titleData) {
    AddMissingSaveObjects(arraySaveKeys, allSaveData);

    AddBuildingProgress_IfMissing(allSaveData[GetProgressKey(CLASS_BUILDING)], titleData[CLASS_BUILDING]);
    AddGuildProgress_IfMissing(allSaveData[GetProgressKey(CLASS_GUILD)], titleData[CLASS_GUILD]);
    AddTrainerProgress_IfMissing(allSaveData);
    AddGameMetrics_IfMissing(allSaveData);
    AddUnitProgress_IfMissing(allSaveData[GetProgressKey(CLASS_UNIT)], titleData[CLASS_UNIT]);
    AddWorldProgress_IfMissing(allSaveData);

    // because I don't want to make another call to get data, I am going to put *very first* stuff in here
    AddNewPlayerData_IfMissing(allSaveData);
}

/// This method will add any save data keys as empty objects
function AddMissingSaveObjects(arrayDataKeys, allSaveData) {
    for (var index in arrayDataKeys) {
        var saveKey = GetProgressKey(arrayDataKeys[index]);        
        
        if(!allSaveData.hasOwnProperty(saveKey)) {
            allSaveData[saveKey] = {};
        }
    }    
}

/// In order to be saved, our hash of objects must be a hash of strings
function StringifySaveData(allSaveData) {
    for (var data in allSaveData) {
        var saveObject = allSaveData[data];
        var saveData = JSON.stringify(saveObject);
        allSaveData[data] = saveData;
    }
}

function AddBuildingProgress_IfMissing(buildingProgress, titleData) {
    for (var buildingKey in titleData) {
        if (!buildingProgress.hasOwnProperty(buildingKey)) {
            var missingProgress = {};
            missingProgress[ID] = buildingKey;
            missingProgress[UPGRADE_LEVEL] = GetDefaultBuildingLevel(buildingKey);

            buildingProgress[buildingKey] = missingProgress;
        }
    }
}

function GetDefaultBuildingLevel(buildingKey) {
    if (buildingKey == "BASE_WARRIOR_BUILDING_1") {
        return 1;
    } else {
        return 0;
    }
}

function AddGuildProgress_IfMissing(guildProgress, titleData) {
    for (var key in titleData) {
        if (!guildProgress.hasOwnProperty(key)) {
            var missingProgress = {};
            missingProgress[ID] = key;
            missingProgress[UPGRADE_LEVEL] = 0;
            missingProgress[UPGRADE_POINTS] = 0;

            guildProgress[key] = missingProgress;
        }
    }    
}

function AddUnitProgress_IfMissing(unitProgress, titleData) {
    for (var key in titleData) {
        if (!unitProgress.hasOwnProperty(key)) {
            var missingProgress = {};
            missingProgress[ID] = key;
            missingProgress[UPGRADE_LEVEL] = GetDefaultUnitLevel(key);
            missingProgress[TRAINERS_ASSIGNED] = 0;
            missingProgress[UNIT_COUNT] = 0;
            missingProgress[LAST_UNIT_COUNT] = 0;

            unitProgress[key] = missingProgress;
        }
    }    
}

function GetDefaultUnitLevel(key) {
    if (key == "BASE_WARRIOR_1") {
        return 1;
    } else {
        return 0;
    }
}

function AddTrainerProgress_IfMissing(allSaveData) {
    if (!allSaveData.hasOwnProperty(TRAINER_SAVE_DATA)) {
        allSaveData[TRAINER_SAVE_DATA] = {};
    }

    var trainerSaveData = allSaveData[TRAINER_SAVE_DATA];
    if (!trainerSaveData.hasOwnProperty(TRAINER_COUNTS)) {
        var trainerCounts = {};
        trainerCounts[NORMAL_TRAINER] = 0;
        trainerSaveData[TRAINER_COUNTS] = trainerCounts;
    }
}

function AddGameMetrics_IfMissing(allSaveData) {
    if (!allSaveData.hasOwnProperty(GAME_METRICS)) {
        allSaveData[GAME_METRICS] = {};        
    }

    var metricsSaveData = allSaveData[GAME_METRICS];
    if (!metricsSaveData.hasOwnProperty(METRICS)) {
        var metrics = {};
        metricsSaveData[METRICS] = metrics;
    }
}

function AddMissionProgres_IfMissing(allSaveData) {
    if (!allSaveData.hasOwnProperty(MISSION_PROGRESS_KEY)) {
        allSaveData[MISSION_PROGRESS_KEY] = {};
    }
}

/// This sets the player's first ever map, if they have no map for the base module
// because I don't want to make another call to get data, I am going to put *very first* stuff in here
function AddNewPlayerData_IfMissing(allSaveData) {    
    var baseMapKey = GetMapSaveKey(MODULE_BASE);

    // the || here is because I can't figure out a way to fully wipe a piece of player save data
    if (!allSaveData.hasOwnProperty(baseMapKey) || !allSaveData[baseMapKey].hasOwnProperty(WORLD)) {
        var firstMapData = GetTitleData(NEW_PLAYER_MAP);
        allSaveData[baseMapKey] = firstMapData;

        var isFirstMap = true;
        CreateMissionProgressForMap(firstMapData, isFirstMap);

        AddStartingCurrency();
    }
}

function AddWorldProgress_IfMissing(allSaveData, allModules) {
    if (!allSaveData.hasOwnProperty(WORLD_PROGRESS_KEY)) {
        allSaveData[WORLD_PROGRESS_KEY] = {};
    }

    var allModules = GetAllModules(); 
    var worldProgressData = allSaveData[WORLD_PROGRESS_KEY]
    for (var i = 0; i < allModules.length; i++) {
        var module = allModules[i];
        if (!worldProgressData.hasOwnProperty(module)) {
            var worldProgress = {};

            worldProgress[ID] = module;
            worldProgress[WORLD_PROGRESS_RESTARTS] = 0;
            worldProgress[WORLD_PROGRESS_CUR_MAP] = 0;

            worldProgressData[module] = worldProgress;
        }
    }        
}

/////////////////////////////////////////////////
/// ~Login
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Client data accessing
/// Methods the client can call to access data
/// that it can't normally access or change.
/////////////////////////////////////////////////

/// Returns all the title data for a particular class (buildings, units, etc)
handlers.getAllDataForClass = function (args) {
    var className = args.data[CLASS];

    var data = GetTitleDataForClass(className);

    return data;
}

function GetDataForTarget(className, targetID) {
    var allDataForClass = GetTitleDataForClass(className);
    var dataForTarget = allDataForClass[targetID];

    return dataForTarget;
}

/// This method used to be a lot more complex, getting multiple title datas for each expansion
function GetTitleDataForClass(className) {
    return GetTitleData(className);
}

/// returns all active modules are currently active in the game
function GetAllModules() {
    var modules = [MODULE_BASE];

    return modules;
}

/////////////////////////////////////////////////
/// ~Client data accessing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Player data access
/// All calls related to getting or setting
/// generic player data.
/////////////////////////////////////////////////

const READ_ONLY = "ReadOnly";
const INTERNAL = "Internal";

function GetReadOnlySaveData(key) {
    var rawData = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId, Keys: [key] });

    return GetSaveObjectFromRawData(rawData, key); 
}

function GetMultipleReadOnlySaveData(keys) {
    var saveDataObject = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId, Keys: keys });
    var allSaveData = saveDataObject[DATA];

    /// Iterate through all the save data in the save data object gotten from the server.
    /// It re-inserts the object's VALUE (the actual data) into the object. This is necessary because
    /// when we re-save the object, this is the format the API wants it in.
    for (var data in allSaveData) {        
        var saveObject = allSaveData[data];
        var saveData = saveObject[VALUE];
        
        allSaveData[data] = JSON.parse(saveData);
    }

    return allSaveData;    
}

function GetAllReadOnlySaveData() {
    var saveDataObject = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId });
    var allSaveData = saveDataObject[DATA];

    /// Iterate through all the save data in the save data object gotten from the server.
    /// It re-inserts the object's VALUE (the actual data) into the object. This is necessary because
    /// when we re-save the object, this is the format the API wants it in.
    for (var data in allSaveData) {
        var saveObject = allSaveData[data];
        var saveData = saveObject[VALUE];
        allSaveData[data] = JSON.parse(saveData);
    }

    return allSaveData;
}

function GetInternalSaveData(key) {
    var rawData = server.GetUserInternalData({ PlayFabId: currentPlayerId, Keys: [key] });
    
    return GetSaveObjectFromRawData(rawData, key);   
}

function GetSaveObjectFromRawData(rawData, key) {
    var actualData = rawData[DATA];
    var data = actualData[key];
    var valueData = JSON.parse(data[VALUE]);

    //log.info("Got save data: " + data[VALUE]);

    return valueData; 
}

function SetReadOnlyData(dataKey, dataAsObject) {
    SetSaveData(dataKey, JSON.stringify(dataAsObject), READ_ONLY);    
}

function SetInternalData(dataKey, dataAsObject) {
    SetSaveData(dataKey, JSON.stringify(dataAsObject), INTERNAL); 
}

function SetSaveData(dataKey, dataAsString, dataType) {
    var data = {};
    data[dataKey] = dataAsString;
    log.info("Saving " + dataType + " data for key " + dataKey + ": " + dataAsString);

    SetSaveDataWithObject(data, dataType);
}

function SetSaveDataWithObject(dataObject, dataType) {
    log.info("Setting save data of " + dataType + ": " + JSON.stringify(dataObject));

    if (dataType == READ_ONLY) {
        server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: dataObject, Permission: "Public"});
    } else if (dataType == INTERNAL) {
        server.UpdateUserInternalData({ PlayFabId: currentPlayerId, Data: dataObject, Permission: "Public"});
    } else {
        log.info("Can't save to data type: " + dataType);
    }
}

/////////////////////////////////////////////////
/// ~Player data access
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Building
/// Methods directly related to buildings. This
/// is like a server side version of the Building 
/// class.
/// Also contains helper functions for accessing
/// elements of a building from save data.
/////////////////////////////////////////////////

function GetCapacityForUnit(unitKey, allBuildingProgress, allBuildingData) {
    var buildingKey = GetBuildingKeyForUnit(unitKey, allBuildingData);
    var capacity = 0;

    if (buildingKey != null) {
        var buildingSaveData = allBuildingProgress[buildingKey];
        var buildingTitleData = allBuildingData[buildingKey];

        var buildingLevel = GetNumberFromProgress(UPGRADE_LEVEL, buildingSaveData);
        var buildingStartSize = GetBuildingStartingSize(buildingTitleData);
        capacity = buildingLevel * buildingStartSize;
    }

    log.info("Getting capacity for building " + buildingKey + ": " + capacity);
    return capacity;
}

function GetBuildingKeyForUnit(unitKey, allBuildingData) {
    //log.info("Trying to get building for unit " + unitKey + ": " + JSON.stringify(allBuildingData));
    for (var buildingKey in allBuildingData) {
        var buildingData = allBuildingData[buildingKey];
        var buildingUnitKey = GetBuildingUnitKey(buildingData);

        if (unitKey == buildingUnitKey) {
            log.info("Found the key: " + buildingKey);
            return buildingKey;
        }
    }

    return null;
}

function GetBuildingUnitKey(buildingData) {
    var key = buildingData[BUILDING_UNIT];
    return key;
}

function GetBuildingStartingSize(buildingTitleData) {
    var startingSize = buildingTitleData[BUILDING_START_SIZE];
    return startingSize;
}

/////////////////////////////////////////////////
/// ~Building
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Currency
/////////////////////////////////////////////////

function AddCurrency(currencyType, amount) {
    server.AddUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: amount });
}

function SubtractCurrency(currencyType, amount) {
    server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: amount });
}

function SetCurrency(currencyType, amountToSet) {
    var playerInventory = GetPlayerInventory();    
    var currentAmount = GetAmountOfCurrency(playerInventory, currencyType);
    var changeInCurrency = currentAmount - amountToSet;    

    log.info("Setting player currency(" + currencyType + ") to " + amountToSet);

    if (changeInCurrency > 0) {
        SubtractCurrency(currencyType, changeInCurrency);        
    } else if (changeInCurrency < 0) {
        AddCurrency(currencyType, Math.abs(changeInCurrency));        
    }
}

function HasEnoughCurrency(playerCurrencies, currencyType, amount) {
    var currentCurrency = playerCurrencies[currencyType];    
    return currentCurrency >= amount;
}

function GetAmountOfCurrency(playerInventory, currencyType) {
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];
    return playerCurrencies[currencyType];
}

function GetPlayerCurrenciesFromInventory(playerInventory) {    
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];

    return playerCurrencies;
}

function AddStartingCurrency() {
    AddCurrency( CURRENCY_GOLD, STARTING_GOLD );
}

/////////////////////////////////////////////////
/// ~Currency
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Misc
/// Misc methods that are used by many different
/// server methods.
/////////////////////////////////////////////////

function returnOutOfSync() {
    return { outOfSync : true };
}

function GetRandomArrayElement(array) {
    var randomElement = array[Math.floor(Math.random() * array.length)];
    return randomElement;
}

function ShuffleArray(array) {
    var j, x, i;
    for (var i = array.length; i; i--) {
        j = Math.floor(Math.random() * i);
        x = array[i - 1];
        array[i - 1] = array[j];
        array[j] = x;
    }
}

/// returns an array of JSON objects for the given data keys
function GetTitleData(titleDataKey) {
    log.info("Getting title data for " + titleDataKey);

    var titleData = server.GetTitleData({ Keys : titleDataKey });    
    var data = titleData[DATA];
    var actualDataAsString = data[titleDataKey];

    var actualDataAsObject = JSON.parse(actualDataAsString);
    //log.info("Title data as string: " + actualDataAsString);

    return actualDataAsObject;
}

function GetMultipleTitleData(arrayKeys) {
    log.info("Getting array of title data for " + JSON.stringify(arrayKeys));

    var arrayData = {};
    var titleData = server.GetTitleData({ Keys : arrayKeys });
    titleData = titleData[DATA];

    // parse all the data into objects so it's easier to use
    for (var dataKey in titleData) {
        var data = titleData[dataKey];
        titleData[dataKey] = JSON.parse(data);
    }
    
    return titleData;
}

function GetPlayerInventory() {
    var inventory = server.GetUserInventory({ PlayFabId: currentPlayerId });

    log.info("Getting player inventory: " + JSON.stringify(inventory));

    return inventory;
}

function GetNumberFromArgs(args, id) {
    var number = parseInt(args.data[id], 10);
    return number;
}

function GetFloatFromArgs(args, id) {
    var float = parseFloat(args.data[id]);
    return float;
}

function GetNumberFromObject(object, key) {
    var num = parseInt(object[key], 10);

    return num;
}

/////////////////////////////////////////////////
/// ~Misc
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// ProgressData
/// Methods related to getting and changing 
/// progress data for a player.
/////////////////////////////////////////////////

/// returns actual progress data from the player's read only data
function GetProgressData(className) {
    var progressKey = GetProgressKey(className);
    var data = GetReadOnlySaveData(progressKey);

    return data;
}

/// returns the key for progress data based on a class name
function GetProgressKey(className) {
    return className + "Progress";
}

/// given read only data of all the progress data for a given class and a target ID,
/// returns the specific piece of progress data for the target
function GetProgressForTarget(readOnlyData, targetID) {    
    var progressData = readOnlyData[targetID];
    
    log.info("Progress data for " + targetID + ": " + progressData);
    return progressData;
}

function GetNumberFromProgress(key, progressData) {
    var num = parseInt(progressData[key], 10);

    return num;
}

/// saves the progress data in player data
function SaveProgressData(className, readOnlyData, progressData, targetID) {
    var progressKey = GetProgressKey(className);
    readOnlyData[targetID] = progressData;

    SetReadOnlyData(progressKey, readOnlyData);
}

function GetLevelFromProgress(progress) {
    var currentLevel = GetNumberFromProgress(UPGRADE_LEVEL, progress);

    log.info("Got current level: " + currentLevel);
    return currentLevel;
}

/////////////////////////////////////////////////
/// ~ProgressData
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Unit
/// Methods directly related to units. This
/// is like a server side version of the Unit 
/// class.
/// Also contains helper functions for accessing
/// elements of a unit from save data.
/////////////////////////////////////////////////

function GetTotalBaseStat(unitData, unitProgress, stat) {
    log.info("Getting total base stat " + stat + " for " + GetUnitID(unitData) + ".");    

    var unitLevel = GetLevelFromProgress(unitProgress);    
    var baseValue = GetUnitBaseStat(unitData, stat);
    var totalValue = baseValue * unitLevel;
    
    log.info("Total base stat value is: " + totalValue + " rounded to " + Math.ceil(totalValue));
    return Math.ceil(totalValue);
}

function GetUnitID(unitData) {
    return unitData[UNIT_ID];
}

function GetUnitBaseStat(unitData, stat) {
    log.info("Getting base stat value of " + stat + " for " + GetUnitID(unitData));

    var baseValue = 0;
    var stats = GetUnitStats(unitData);
    if (stats.hasOwnProperty(stat)) {
        var statData = GetStatData(stats, stat);
        baseValue = parseFloat(statData[STAT_BASE]);
    }

    log.info("Base stat: " + baseValue);
    return baseValue;
}

function GetUnitStats(unitData) {
    var stats = unitData[UNIT_STATS];

    log.info("Got stats: " + stats);
    return JSON.parse(stats);
}

function GetStatData(stats, statName) {
    var statData = stats[statName];

    log.info("Got " + JSON.stringify(statData));
    return statData;
}

/////////////////////////////////////////////////
/// ~Unit
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// UnitCounting
/////////////////////////////////////////////////

function UpdateAllUnitCounts(time) {
    log.info("Updating all unit counts");

    var allUnitProgress = GetProgressData(CLASS_UNIT);
    var allUnitData = GetTitleDataForClass(CLASS_UNIT);
    var allBuildingProgress = GetProgressData(CLASS_BUILDING);
    var allBuildingData = GetTitleDataForClass(CLASS_BUILDING);
    
    for (var unitKey in allUnitProgress) {
        UpdateCountForUnit(unitKey, allUnitProgress, allUnitData, allBuildingProgress, allBuildingData, time);        
    }

    UpdateUnitSaveData(allUnitProgress); 
}

function UpdateUnitSaveData(allUnitProgress) {
    var key = GetProgressKey(CLASS_UNIT);
    SetReadOnlyData(key, allUnitProgress);
}

function UpdateCountForUnit(unitKey, allUnitProgress, allUnitData, allBuildingProgress, allBuildingData, timeNow) {
    log.info("Updating count for " + unitKey);
    var unitSaveData = allUnitProgress[unitKey];
    var unitTitleData = allUnitData[unitKey];    
    var unitCountIncrease = GetUnitCountIncrease(unitSaveData, unitTitleData, timeNow);

    var maxCount = GetCapacityForUnit(unitKey, allBuildingProgress, allBuildingData);
    var oldCount = GetUnitCount(unitSaveData);
    var newCount = Math.min(oldCount + unitCountIncrease, maxCount);
    UpdateUnitCount(unitSaveData, newCount, timeNow);    

    log.info("Setting count for " + unitKey + " from " + oldCount + " to " + newCount);
}

function UpdateUnitCount(unitSaveData, count, time) {
    SetUnitCount(unitSaveData, count);
    SetUnitLastCountTime(unitSaveData, time);
}

function ResetUnitCount(unitSaveData) {
    UpdateUnitCount(unitSaveData, 0, Date.now());
}

/// NOTE: This method assumes you're doing something legal (changed count > 0, < max)
function ChangeUnitCount(unitSaveData, amount) {
    var currentCount = GetUnitCount(unitSaveData);
    var newCount = currentCount + amount;

    log.info("Changing count from " + currentCount + " to " + newCount + "(" + amount +")");
    UpdateUnitCount(unitSaveData, newCount, Date.now());
}

function SetUnitCount(unitSaveData, count) {
    unitSaveData[UNIT_COUNT] = count;
}

function SetUnitLastCountTime(unitSaveData, time) {
    unitSaveData[LAST_UNIT_COUNT] = time;
}

function GetUnitCount(unitSaveData) {
    if (!unitSaveData.hasOwnProperty(UNIT_COUNT)) {
        unitSaveData[UNIT_COUNT] = 0;
    }

    var count = parseInt(unitSaveData[UNIT_COUNT], 10);

    log.info("Returning unit count: " + count);
    return count;
}

function HasEnoughUnits(unitSaveData, count) {
    var currentCount = GetUnitCount(unitSaveData);
    return currentCount >= count;
}

function GetUnitLastCountTime(unitSaveData) {
    if (!unitSaveData.hasOwnProperty(LAST_UNIT_COUNT)) {
        unitSaveData[LAST_UNIT_COUNT] = Date.now();
    }

    var lastCount = parseInt(unitSaveData[LAST_UNIT_COUNT], 10);

    log.info("Last count time for unit: " + lastCount);
    return lastCount;
}

function GetUnitCountIncrease(unitSaveData, unitTitleData, time) {
    var lastCountTime = GetUnitLastCountTime(unitSaveData);
    var timeElapsed = Math.max(time - lastCountTime, 0);
    var timeElapsedSeconds = timeElapsed / 1000;
    log.info("Getting unit count progress with time difference: " + timeElapsedSeconds);

    var progressPerSecond = GetUnitProgressPerSecond(unitSaveData, unitTitleData);
    var progress = timeElapsedSeconds * progressPerSecond;

    log.info("The progress is: " + progress);
    return progress;
}

function GetUnitProgressPerSecond(unitSaveData, unitTitleData) {
    var speed = GetUnitProgressSpeed(unitSaveData);
    var progressPerSecond = unitTitleData[UNIT_BASE_PROGRESS] / speed;

    return progressPerSecond;
}

function GetUnitProgressSpeed(unitSaveData) {    
    var level = GetNumberFromProgress(UPGRADE_LEVEL, unitSaveData);
    var trainerLevel = GetNumberFromProgress(TRAINERS_ASSIGNED, unitSaveData);
    var speed = level + 1 - trainerLevel;
    speed = Math.max( speed, 1 );
    log.info("Getting unit progress speed: " + speed);

    return speed;
}

/////////////////////////////////////////////////
/// ~UnitCounting
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// TrainerAssignment
/// Related to assigning/unassigning trainers
/// to units.
/////////////////////////////////////////////////

handlers.initiateChangeInTraining = function (args) {
    var targetUnitID = args.data[TARGET_ID];
    var changeInTrainingLevel = GetNumberFromArgs(args, CHANGE);

    log.info(targetUnitID);
    log.info("initiateChangeInTraining for " + targetUnitID + " by " + changeInTrainingLevel);

    var allProgressData = GetProgressData(CLASS_UNIT);
    var progressDataForUnit = GetProgressForTarget(allProgressData, targetUnitID);
    log.info("Progress data: " + JSON.stringify(progressDataForUnit));

    if (CanChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel)) {
        ChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel, targetUnitID, CLASS_UNIT)
    } else {
        return { outOfSync : true };
    }
}

function GetAvailableTrainers(allProgressData) {
    var totalTrainers = GetTotalTrainers();
    var trainersInUse = 0;

    for (var unitKey in allProgressData) {
        var unit = allProgressData[unitKey];
        trainersInUse += parseInt(unit[TRAINERS_ASSIGNED], 10);
    }
    
    var availableTrainers = totalTrainers - trainersInUse;
    log.info("Available Trainers: " + availableTrainers);
    return availableTrainers;
}

function GetTotalTrainers() {
    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var totalTrainers = 0;

    for (var trainerType in trainerCounts) {
        totalTrainers += trainerCounts[trainerType];
    }

    log.info("Total trainers: " + totalTrainers);
    return totalTrainers;   
}

function CanChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel) {
    var maxLevel = GetMaxTrainingLevel(progressDataForUnit);
    var changeResult = parseInt(progressDataForUnit[TRAINERS_ASSIGNED], 10) + changeInTrainingLevel;
    var availableTrainers = GetAvailableTrainers(allProgressData);

    var isChangeOK = false;
    if (changeInTrainingLevel < 0) {
        isChangeOK = changeResult >= 0;
    } else {
        isChangeOK = availableTrainers > 0 && changeResult <= maxLevel;
    }    

    log.info("Checking change against max level " + maxLevel + " with a changeResult " + changeResult);
    log.info("Can make change: " + isChangeOK);
    return isChangeOK;
}

function GetMaxTrainingLevel(progressDataForUnit) {
    return progressDataForUnit[UPGRADE_LEVEL];
}

function ChangeTrainingLevel(allProgressData, progressData, changeInTrainers, targetID, className) {
    UpdateCountDueToChangeInTraining(targetID, allProgressData);    

    var progressKey = GetProgressKey(className);
    var trainersAssigned = parseInt(progressData[TRAINERS_ASSIGNED], 10) + changeInTrainers;
    progressData[TRAINERS_ASSIGNED] = trainersAssigned;
    allProgressData[targetID] = progressData;    

    SetReadOnlyData(progressKey, allProgressData);
}

function UpdateCountDueToChangeInTraining(targetID, allProgressData) {
    var allUnitData = GetTitleDataForClass(CLASS_UNIT);
    var allBuildingProgress = GetProgressData(CLASS_BUILDING);
    var allBuildingData = GetTitleDataForClass(CLASS_BUILDING);

    UpdateCountForUnit(targetID, allProgressData, allUnitData, allBuildingProgress, allBuildingData, Date.now());
}

/////////////////////////////////////////////////
/// ~TrainerAssignment
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// TrainerPurchasing
/// Related to trainer purchasing.
/////////////////////////////////////////////////

/// The client calls this method to initiate a purchase of a normal trainer
handlers.initiateTrainerPurchase = function (args) {
    var playerInventory = GetPlayerInventory();
    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);

    if ( CanPurchaseTrainer(trainerSaveData, playerInventory) ) {
        PayForTrainer(trainerSaveData);

        AddTrainer(trainerSaveData);
    } else {
        return { outOfSync : true };
    }
}

function CanPurchaseTrainer(trainerSaveData, playerInventory) {
    var playerCurrencies = GetPlayerCurrenciesFromInventory(playerInventory);
    var cost = GetNextTrainerCost(trainerSaveData);

    var canPurchase = HasEnoughCurrency(playerCurrencies, CURRENCY_GOLD, cost);
    log.info("Can purchase new trainer: " + canPurchase);

    return canPurchase;
}

function GetNextTrainerCost(trainerSaveData) {
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var normalTrainers = trainerCounts[NORMAL_TRAINER];
    var cost = Math.ceil(BASE_TRAINER_COST * Math.pow(TRAINER_UPGRADE_COEFFICIENT, normalTrainers));

    log.info("Cost for a new normal trainer: " + cost);
    return cost;
}

function PayForTrainer(trainerSaveData) {
    var cost = GetNextTrainerCost(trainerSaveData);

    log.info("Paying for trainer: " + cost);

    server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: CURRENCY_GOLD, Amount: cost });
}

function AddTrainer(trainerSaveData) {
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    trainerCounts[NORMAL_TRAINER] += 1;

    SetReadOnlyData(TRAINER_SAVE_DATA, trainerSaveData);
}

/////////////////////////////////////////////////
/// ~TrainerPurchasing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Upgradeables
/// Methods the client can invoke related to an
/// upgradeable class.
/////////////////////////////////////////////////

/// The client calls this method to initiate an upgrade on a given upgradeable.
handlers.initiateUpgrade = function (args) {
    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var upgradeID = args.data[UPGRADE_ID];

    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var readOnlyData = GetProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);

    var playerInventory = GetPlayerInventory();

    if ( CanUpgrade(upgradeData, progressData, playerInventory) ) {
        PayForUpgrade(upgradeData, progressData, playerInventory);

        UpgradeAndSave(readOnlyData, className, progressData, targetID);
    } else {
        return { outOfSync : true };
    }
}

/// returns the upgrade data for a target ID, given a class name and upgrade ID
function GetUpgradeDataForTarget(className, targetID, upgradeID) {
    var dataForTarget = GetDataForTarget(className, targetID);
    var upgradeData = JSON.parse(dataForTarget[upgradeID]);

    return upgradeData;
}

/// checks to see if an upgrade can happen, given progress data for the target and the player's inventory
function CanUpgrade(upgradeData, progressData, playerInventory) {
    if (IsAtMaxLevel(upgradeData, progressData) || !CanAffordUpgrade(upgradeData, progressData, playerInventory)) {
        return false;
    }

    return true;
}

/// checks to see if an upgrade is at max level
function IsAtMaxLevel(upgradeData, progressData) {
    return progressData[UPGRADE_LEVEL] >= GetUpgradeDataMaxLevel(upgradeData);
}

/// checks to see if the player can afford an upgrade
function CanAffordUpgrade(upgradeData, progressData, playerInventory) {
    var playerCurrencies = GetPlayerCurrenciesFromInventory(playerInventory);
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];

    for (var resource in resourcesToUpgrade) {
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
        
        if(!HasEnoughCurrency(playerCurrencies, resource, cost)) {
            return false;
        }
    }

    return true;
}

/// deducts the cost of an upgrade from the player
function PayForUpgrade(upgradeData, progressData, playerInventory) {
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];    

    for (var resource in resourcesToUpgrade) {        
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
                
        server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: resource, Amount: cost });
    }
}

/// actually upgrades a target and saves it to the player's save data
function UpgradeAndSave(readOnlyData, className, progressData, targetID) {
    Upgrade(readOnlyData, className, progressData, targetID);

    SaveProgressData(className, readOnlyData, progressData, targetID);
}

/// increases the upgrade level of the incoming progress data
function Upgrade(readOnlyData, className, progressData, targetID) {    
    progressData[UPGRADE_LEVEL] += 1;

    if (className == CLASS_UNIT) {
        ResetUnitCount(progressData);        
    }
}

/// given the resources to upgrade a target, a given resource, and the progress data for the target,
/// returns the cost in currency to upgrade that resource
function GetUpgradeCost(resourcesToUpgrade, resource, progressData) {
    var level = progressData[UPGRADE_LEVEL];
    var coefficient = progressData[COEFFICIENT];
    var costPerLevel = resourcesToUpgrade[resource];
    var cost = Math.ceil(costPerLevel * Math.pow(coefficient, level-1));

    return cost;
}

/////////////////////////////////////////////////
/// ~Upgradeables
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// PointsUpgradeables
/////////////////////////////////////////////////

/// server method for adding points to an upgradeable
function AddPointsToUpgradeParent(className, targetID, upgradeID, pointsToAdd, args) {
    log.info("Adding " + pointsToAdd + " to " + targetID);

    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var allProgressDataForClass = GetProgressData(className);
    var progressDataForTarget = GetProgressForTarget(allProgressDataForClass, targetID);

    AddPointsToUpgrade(progressDataForTarget, pointsToAdd, upgradeData, allProgressDataForClass, args);
}

/// adds the incoming points to this upgradeable
function AddPointsToUpgrade(progressDataForTarget, pointsToAdd, upgradeData, allProgressDataForClass, args) {
    pointsToAdd = Math.max(pointsToAdd, 0);

    var points = GetNumberFromProgress(UPGRADE_POINTS, progressDataForTarget);
    points += pointsToAdd;
    log.info("Adding " + pointsToAdd + " points.");

    SetPoints(progressDataForTarget, points, upgradeData, allProgressDataForClass, args);        
}

/// sets the points for this upgradeable to the incoming value
function SetPoints(progressDataForTarget, points, upgradeData, allProgressDataForClass, args) {
    if (IsAtMaxLevel(upgradeData, progressDataForTarget)) {
        points = 0;
    }

    progressDataForTarget[UPGRADE_POINTS] = points;
    log.info("Setting points to " + points);

    CheckForUpgrade(progressDataForTarget, points, upgradeData, allProgressDataForClass, args);
}

/// checks to see if this upgradeable should be upgraded based on its current xp
function CheckForUpgrade(progressDataForTarget, points, upgradeData, allProgressDataForClass, args) {
    log.info("Checking for upgrade for " + args.data[TARGET_ID]);
    var pointsToLevel = GetTotalPointsForNextLevel(progressDataForTarget, upgradeData);
    var currentPoints = GetNumberFromProgress(UPGRADE_POINTS, progressDataForTarget);

    if ( currentPoints >= pointsToLevel ) {
        log.info("Upgrade!");
        Upgrade(allProgressDataForClass, args.data[CLASS], progressDataForTarget, args.data[TARGET_ID]);
        currentPoints = currentPoints - pointsToLevel;
        SetPoints(progressDataForTarget, currentPoints, upgradeData, allProgressDataForClass, args);
    } else {
        log.info("No upgrade -- saving data");
        SaveProgressData(args.data[CLASS], allProgressDataForClass, progressDataForTarget, args.data[TARGET_ID])
    }
}

/// returns the total points required to advance this upgradeable to the next level
function GetTotalPointsForNextLevel(progressDataForTarget, upgradeData) {
    var currentLevel = GetNumberFromProgress(UPGRADE_LEVEL, progressDataForTarget);
    var baseXpToLevel = GetBaseXpToLevel(upgradeData);
    var totalPoints = baseXpToLevel * currentLevel;
    log.info("Total points to next level: " + totalPoints)

    return totalPoints;
}

/// server method that adds progress (i.e. 100%, 50%, etc) worth of xp to an upgrade
function AddProgressToUpgrade(className, targetID, upgradeID, totalProgressToAdd, args) {
    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var allProgressDataForClass = GetProgressData(className);
    var progressDataForTarget = GetProgressForTarget(allProgressDataForClass, targetID);

    log.info("Adding " + totalProgressToAdd + " progress to " + targetID);

    do {
        var currentProgress = GetCurrentProgress(progressDataForTarget, upgradeData);
        var progressToAdd = Math.min(totalProgressToAdd, 1 - currentProgress);
        var pointsToAdd = progressToAdd * GetTotalPointsForNextLevel(progressDataForTarget, upgradeData);

        log.info("About to add " + pointsToAdd + "(" + progressToAdd + ")");
        AddPointsToUpgrade(progressDataForTarget, pointsToAdd, upgradeData, allProgressDataForClass, args);
        totalProgressToAdd -= progressToAdd;
    } while (totalProgressToAdd > 0);
}

/// return the current progress % as a float
function GetCurrentProgress(progressDataForTarget, upgradeData) {
    var currentPoints = GetNumberFromProgress(UPGRADE_POINTS, progressDataForTarget);
    var totalPointsToNextLevel = GetTotalPointsForNextLevel(progressDataForTarget, upgradeData);
    var currentProgress = currentPoints / totalPointsToNextLevel;

    log.info("Current progress: " + currentProgress);
    return currentProgress;
}

/////////////////////////////////////////////////
/// ~PointsUpgradeables
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// UpgradeData
/////////////////////////////////////////////////

function GetBaseXpToLevel(upgradeData) {
    return parseInt(upgradeData[BASE_XP_TO_LEVEL], 10);
}

function GetUpgradeDataMaxLevel(upgradeData) {
    return upgradeData[MAX_LEVEL];
}

/////////////////////////////////////////////////
/// ~UpgradeData
/////////////////////////////////////////////////