/// NOTE: methods that start with handlers.(methodName) are methods accessible from the client.
/// All other methods are for the SERVER only!!! Do not change these lightly.
/// This file is clearly enormous. I've tried my best to "extract till I drop" and comment everything.
/// Because there are server API limits (10 per call), a lot of methods require the data structures from
/// the API calls to be passed in, so I don't wind up hitting the API a massive number of times.

/////////////////////////////////////////////////
/// Constants
/// Constants used in methods throughout the
/// cloud script.
/////////////////////////////////////////////////

/// game specific
const UPGRADE_LEVEL = "Level";  // key for a level upgrade
const CLASS = "Class";          // key used from client as to what type of data (building, unit, etc) is involved in the call
const TARGET_ID = "TargetID";   // key used from client as to what specific object is involved in the call
const CHANGE = "Change";        // key used from client to pass up a change

// unit counting
const LAST_UNIT_COUNT = "LastCountTime";            // key for timestamp of last unit count update (in unit's progress data)
const UNIT_COUNT = "Count";                         // key in unit's save data for # of that unit
const UNIT_BASE_PROGRESS = "BaseProgressPerSecond"; // key in unit's title data for base progress per second
const COUNT_TIME = "Time";                           // for testing unit counting; time to pretend it is

// buildings
const BUILDING_START_SIZE = "StartingSize";         // key for building title data: the building's starting size
const BUILDING_UNIT = "Unit";                       // key for building title data: the building's unit

// currencies
const CURRENCY_GOLD = "G1";

// upgrade related
const UPGRADE_ID = "UpgradeID";                 // key used from client as to what upgradeable on the target is involed in the call
const UPGRADE_RESOURCES = "ResourcesToUpgrade"; // key for finding list of resources that an upgrade requires

// trainer related
const TRAINER_SAVE_DATA = "TrainerSaveData";    // key for player's trainer save data
const TRAINER_COUNTS = "TrainerCounts";         // key for trainer counts within the trainer save data object
const NORMAL_TRAINER = "Normal";                // the normal trainers a player can purchase
const TRAINERS_ASSIGNED = "Trainers";           // key in unit progress data for the # of trainers assigned to the unit
const BASE_TRAINER_COST = 1000;                 // base gold cost for a trainer

/// game modules
const MODULE_BASE = "Base";    // the base game!

/// classes of objects in the game
const CLASS_BUILDING = "Buildings";     // game buildings that produce units
const CLASS_UNIT = "Units";             // units that are apart of buildings

/// testing
const SAVE_KEY = "SaveKey";             // for accessing some save data
const DATA_ACCESS = "DataAccess";       // for specifying internal, read only, etc

/// API specific
const VIRTUAL_CURRENCY = "VirtualCurrency"; // API key for virtual currency
const DATA = "Data";                        // API key for accessing data after getting the save data
const VALUE = "Value";                      // API key for accessing the actual data value after getting the save data

/////////////////////////////////////////////////
/// ~Constants
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Testing
/// These methods should all check that the
/// account is a testing account with isTesting().
/// These methods exist to edit save data and
/// currency in preperation for running very
/// specific integration tests.
/////////////////////////////////////////////////

/// Checks to see if the account is marked for testing.
function isTesting() {
    var internalData = server.GetUserInternalData({ PlayFabId: currentPlayerId, Keys: ["Testing"] });    
    var data = internalData[DATA];
    var value = data["Testing"];
    var isTesting = value[VALUE] == "true";
    
    log.info("Account Test Status: " + isTesting);

    return isTesting;
}

handlers.overLimit = function (args) {
    var one = isTesting();
    var two = isTesting();
    var three = isTesting();
    var four = isTesting();
    var five = isTesting();
    var six = isTesting();
    var seven = isTesting();
    var eight = isTesting();
    var nine = isTesting();
    var ten = isTesting();
    var eleven = isTesting();
    var twelve = isTesting();
}

/// use this method to test if unit counts are updating properly
handlers.testUpdateUnitCount = function (args) {
    if (!isTesting) {
        return;    
    }

    var time = parseInt(args.data[COUNT_TIME], 10);
    UpdateAllUnitCounts(time);
}

/// use this method if you want to upgrade an upgradeable, bypassing all other normal checks
handlers.testUpgrade = function (args) {
    if (!isTesting) {
        return;    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var allProgressData = GetProgressData(className);
    var progressForTarget = GetProgressForTarget(allProgressData, targetID);    

    Upgrade(allProgressData, className, progressForTarget, targetID);
}

/// use this method if you want to train a unit, bypassing all other normal checks
handlers.testChangeTraining = function (args) {
    if (!isTesting) {
        return;    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var changeInTrainers = parseInt(args.data[CHANGE], 10);
    var allProgressData = GetProgressData(className);
    var progressForTarget = GetProgressForTarget(allProgressData, targetID);

    ChangeTrainingLevel(allProgressData, progressForTarget, changeInTrainers, targetID, className);
}

/// returns the capacity for a unit
handlers.getCapacityForUnit = function(args) {
    if (!isTesting) {
        return;    
    }

    var unitKey = args.data[TARGET_ID];
    var allBuildingProgress = GetProgressData(CLASS_BUILDING);
    var allBuildingData = GetTitleDataForClass(CLASS_BUILDING);

    var capacity = GetCapacityForUnit(unitKey, allBuildingProgress, allBuildingData);
    return ReturnDataToClient(capacity);
}

/// returns the elapsed time needed to train the unit to the desired number
handlers.getTrainTimeForUnit = function(args) {
    if (!isTesting) {
        return;    
    }

    var unitKey = args.data[TARGET_ID];
    var change = parseInt(args.data[CHANGE], 10);

    var allUnitProgress = GetProgressData(CLASS_UNIT);
    var allUnitData = GetTitleDataForClass(CLASS_UNIT);

    var unitSaveData = allUnitProgress[unitKey];
    var unitTitleData = allUnitData[unitKey];    

    var progressPerSecond = GetUnitProgressPerSecond(unitSaveData, unitTitleData);
    var elapsedTime = (change / progressPerSecond) * 1000;

    return ReturnDataToClient(elapsedTime);
}

/// returns the # of units the player currently has
handlers.getUnitCount = function (args) {
    if (!isTesting) {
        return;    
    }

    var readOnlyData = GetProgressData(CLASS_UNIT);
    var targetID = args.data[TARGET_ID];    
    var progressData = GetProgressForTarget(readOnlyData, targetID);

    var count = GetUnitCount(progressData);
    return ReturnDataToClient(count);
}

/// returns the progress data for a specific class and ID.
/// Used to check that a very specific portion of data changed.
handlers.getProgressData = function (args) {
    if (!isTesting) {
        return;    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];

    var readOnlyData = GetProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);
        
    return ReturnDataToClient(progressData);    
}

/// returns the normal trainer count of the player
handlers.getTrainerCount = function (args) {
    if (!isTesting) {
        return;    
    }

    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var normalTrainers = trainerCounts[NORMAL_TRAINER];

    return ReturnDataToClient(normalTrainers);
}

/// for getting at internal data
handlers.getInternalData = function(args) {
    var key = args.data[SAVE_KEY];
    var value = GetInternalSaveData(key);   
    
    return ReturnDataToClient(value);
}

/// returns the # of available trainers
handlers.getAvailableTrainers = function(args) {
    var allProgressData = GetProgressData(CLASS_UNIT);
    var availableTrainers = GetAvailableTrainers(allProgressData);

    return ReturnDataToClient(availableTrainers);
}

/// sets player data of a key to a value
handlers.setSaveData = function(args) {
    if (!isTesting) {
        return;
    }

    var key = args.data["Key"];
    var value = args.data[VALUE];
    var access = args.data[DATA_ACCESS];

    SetSaveData(key, value, access);
}

/// convenience function that turns some raw data into a json string to send back to client
function ReturnDataToClient(rawData) {
    var dataToString = JSON.stringify(rawData);
    log.info("Returning test data to client: " + dataToString);

    var data = { data : dataToString }
    return data;
}

/// sets a type of the player's currency to a value.
/// this has to be done by adding or subtracting the difference of
/// the incoming value depending on the player's current currency,
/// because there is no API call to set a currency to a specific value.
handlers.setPlayerCurrency = function(args) {
    if (!isTesting) {
        return;
    }

    var amountToSet = args.data["Amount"];
    var currencyType = args.data["Type"];

    var playerInventory = GetPlayerInventory();    
    var currentAmount = GetAmountOfCurrency(playerInventory, currencyType);
    var changeInCurrency = currentAmount - amountToSet;    

    log.info("Setting player currency(" + currencyType + ") to " + amountToSet);

    if (changeInCurrency > 0) {
        server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: changeInCurrency });
    } else if (changeInCurrency < 0) {
        server.AddUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: Math.abs(changeInCurrency) });
    }
}

/////////////////////////////////////////////////
/// ~Testing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Login
/////////////////////////////////////////////////

handlers.onLogin = function (args) {
    UpdateAllUnitCounts(Date.now());
}

/////////////////////////////////////////////////
/// ~Login
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Client data accessing
/// Methods the client can call to access data
/// that it can't normally access or change.
/////////////////////////////////////////////////

/// Returns all the title data for a particular class (buildings, units, etc)
handlers.getAllDataForClass = function (args) {
    var className = args.data[CLASS];

    var data = GetTitleDataForClass(className);

    return data;
}

function GetDataForTarget(className, targetID) {
    var allDataForClass = GetTitleDataForClass(className);
    var dataForTarget = allDataForClass[targetID];

    return dataForTarget;
}

function GetTitleDataForClass(className) {
    var moduleNames = GetAllModules();
    for (var i = 0; i < moduleNames.length; i++) {
        moduleNames[i] += className;
    }

    var titleData = server.GetTitleData({ Keys : moduleNames });
    var dataPerModule = titleData[DATA];
    var classData = {};

    for (var moduleKey in dataPerModule) {
        var classesInModule = JSON.parse(dataPerModule[moduleKey]);

        for(var data in classesInModule) {
            classData[data] = classesInModule[data];
        }
    }

    log.info("Getting title data for " + className + ": " + JSON.stringify(classData));

    return classData;
}

/// returns all active modules are currently active in the game
function GetAllModules() {
    var modules = [MODULE_BASE];

    return modules;
}

/////////////////////////////////////////////////
/// ~Client data accessing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Player data access
/// All calls related to getting or setting
/// generic player data.
/////////////////////////////////////////////////

const READ_ONLY = "ReadOnly";
const INTERNAL = "Internal";

function GetReadOnlySaveData(key) {
    var rawData = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId, Keys: [key] });

    return GetSaveObjectFromRawData(rawData, key); 
}

function GetInternalSaveData(key) {
    var rawData = server.GetUserInternalData({ PlayFabId: currentPlayerId, Keys: [key] });
    
    return GetSaveObjectFromRawData(rawData, key);   
}

function GetSaveObjectFromRawData(rawData, key) {
    var actualData = rawData[DATA];
    var data = actualData[key];
    var valueData = JSON.parse(data[VALUE]);

    log.info("Got save data: " + data[VALUE]);

    return valueData; 
}

function SetReadOnlyData(dataKey, dataAsObject) {
    SetSaveData(dataKey, JSON.stringify(dataAsObject), READ_ONLY);    
}

function SetInternalData(dataKey, dataAsObject) {
    SetSaveData(dataKey, JSON.stringify(dataAsObject), INTERNAL); 
}

function SetSaveData(dataKey, dataAsString, dataType) {
    var data = {};
    data[dataKey] = dataAsString;
    log.info("Saving " + dataType + " data for key " + dataKey + ": " + dataAsString);

    if (dataType == READ_ONLY) {
        server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: data, Permission: "Public"});
    } else if (dataType == INTERNAL) {
        server.UpdateUserInternalData({ PlayFabId: currentPlayerId, Data: data, Permission: "Public"});
    } else {
        log.info("Can't save to data type: " + dataType);
    }
}

/////////////////////////////////////////////////
/// ~Player data access
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Building
/// Methods directly related to buildings. This
/// is like a server side version of the Building 
/// class.
/// Also contains helper functions for accessing
/// elements of a building from save data.
/////////////////////////////////////////////////

function GetCapacityForUnit(unitKey, allBuildingProgress, allBuildingData) {
    var buildingKey = GetBuildingKeyForUnit(unitKey, allBuildingData);
    var capacity = 0;

    if (buildingKey != null) {
        var buildingSaveData = allBuildingProgress[buildingKey];
        var buildingTitleData = allBuildingData[buildingKey];

        var buildingLevel = GetNumberFromProgress(UPGRADE_LEVEL, buildingSaveData);
        var buildingStartSize = GetBuildingStartingSize(buildingTitleData);
        capacity = buildingLevel * buildingStartSize;
    }

    log.info("Getting capacity for building " + buildingKey + ": " + capacity);
    return capacity;
}

function GetBuildingKeyForUnit(unitKey, allBuildingData) {
    log.info("Trying to get building for unit " + unitKey + ": " + JSON.stringify(allBuildingData));
    for (var buildingKey in allBuildingData) {
        var buildingData = allBuildingData[buildingKey];
        var buildingUnitKey = GetBuildingUnitKey(buildingData);

        if (unitKey == buildingUnitKey) {
            log.info("Found the key: " + buildingKey);
            return buildingKey;
        }
    }

    return null;
}

function GetBuildingUnitKey(buildingData) {
    var key = buildingData[BUILDING_UNIT];
    return key;
}

function GetBuildingStartingSize(buildingTitleData) {
    var startingSize = buildingTitleData[BUILDING_START_SIZE];
    return startingSize;
}

/////////////////////////////////////////////////
/// ~Building
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Misc
/// Misc methods that are used by many different
/// server methods.
/////////////////////////////////////////////////

function GetPlayerInventory() {
    var inventory = server.GetUserInventory({ PlayFabId: currentPlayerId });

    log.info("Getting player inventory: " + JSON.stringify(inventory));

    return inventory;
}

function HasEnoughCurrency(playerCurrencies, currencyType, amount) {
    var currentCurrency = playerCurrencies[currencyType];    
    return currentCurrency >= amount;
}

function GetAmountOfCurrency(playerInventory, currencyType) {
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];
    return playerCurrencies[currencyType];
}

function GetPlayerCurrenciesFromInventory(playerInventory) {    
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];

    return playerCurrencies;
}

/////////////////////////////////////////////////
/// ~Misc
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// ProgressData
/// Methods related to getting and changing 
/// progress data for a player.
/////////////////////////////////////////////////

/// returns actual progress data from the player's read only data
function GetProgressData(className) {
    var progressKey = GetProgressKey(className);
    var data = GetReadOnlySaveData(progressKey);

    return data;
}

/// returns the key for progress data based on a class name
function GetProgressKey(className) {
    return className + "Progress";
}

/// given read only data of all the progress data for a given class and a target ID,
/// returns the specific piece of progress data for the target
function GetProgressForTarget(readOnlyData, targetID) {    
    var progressData = readOnlyData[targetID];
    
    log.info("Progress data for " + targetID + ": " + progressData);
    return progressData;
}

function GetNumberFromProgress(key, progressData) {
    var num = parseInt(progressData[key], 10);

    return num;
}

/////////////////////////////////////////////////
/// ~ProgressData
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Unit
/// Methods directly related to units. This
/// is like a server side version of the Unit 
/// class.
/// Also contains helper functions for accessing
/// elements of a unit from save data.
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// ~Unit
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// UnitCounting
/////////////////////////////////////////////////

function UpdateAllUnitCounts(time) {
    log.info("Updating all unit counts");

    var allUnitProgress = GetProgressData(CLASS_UNIT);
    var allUnitData = GetTitleDataForClass(CLASS_UNIT);
    var allBuildingProgress = GetProgressData(CLASS_BUILDING);
    var allBuildingData = GetTitleDataForClass(CLASS_BUILDING);
    
    for (var unitKey in allUnitProgress) {
        UpdateCountForUnit(unitKey, allUnitProgress, allUnitData, allBuildingProgress, allBuildingData, time);        
    }

    UpdateUnitSaveData(allUnitProgress); 
}

function UpdateUnitSaveData(allUnitProgress) {
    var key = GetProgressKey(CLASS_UNIT);
    SetReadOnlyData(key, allUnitProgress);
}

function UpdateCountForUnit(unitKey, allUnitProgress, allUnitData, allBuildingProgress, allBuildingData, timeNow) {
    log.info("Updating count for " + unitKey);
    var unitSaveData = allUnitProgress[unitKey];
    var unitTitleData = allUnitData[unitKey];    
    var unitCountIncrease = GetUnitCountIncrease(unitSaveData, unitTitleData, timeNow);

    var maxCount = GetCapacityForUnit(unitKey, allBuildingProgress, allBuildingData);
    var oldCount = GetUnitCount(unitSaveData);
    var newCount = Math.min(oldCount + unitCountIncrease, maxCount);
    UpdateUnitCount(unitSaveData, newCount, timeNow);    

    log.info("Setting count for " + unitKey + " from " + oldCount + " to " + newCount);
}

function UpdateUnitCount(unitSaveData, count, time) {
    SetUnitCount(unitSaveData, count);
    SetUnitLastCountTime(unitSaveData, time);
}

function ResetUnitCount(unitSaveData) {
    UpdateUnitCount(unitSaveData, 0, Date.now());
}

function SetUnitCount(unitSaveData, count) {
    unitSaveData[UNIT_COUNT] = count;
}

function SetUnitLastCountTime(unitSaveData, time) {
    unitSaveData[LAST_UNIT_COUNT] = time;
}

function GetUnitCount(unitSaveData) {
    if (!unitSaveData.hasOwnProperty(UNIT_COUNT)) {
        unitSaveData[UNIT_COUNT] = 0;
    }

    var count = parseInt(unitSaveData[UNIT_COUNT], 10);

    log.info("Returning unit count: " + count);
    return count;
}

function GetUnitLastCountTime(unitSaveData) {
    if (!unitSaveData.hasOwnProperty(LAST_UNIT_COUNT)) {
        unitSaveData[LAST_UNIT_COUNT] = Date.now();
    }

    var lastCount = parseInt(unitSaveData[LAST_UNIT_COUNT], 10);

    log.info("Last count time for unit: " + lastCount);
    return lastCount;
}

function GetUnitCountIncrease(unitSaveData, unitTitleData, time) {
    var lastCountTime = GetUnitLastCountTime(unitSaveData);
    var timeElapsed = Math.max(time - lastCountTime, 0);
    var timeElapsedSeconds = timeElapsed / 1000;
    log.info("Getting unit count progress with time difference: " + timeElapsedSeconds);

    var progressPerSecond = GetUnitProgressPerSecond(unitSaveData, unitTitleData);
    var progress = timeElapsedSeconds * progressPerSecond;

    log.info("The progress is: " + progress);
    return progress;
}

function GetUnitProgressPerSecond(unitSaveData, unitTitleData) {
    var speed = GetUnitProgressSpeed(unitSaveData);
    var progressPerSecond = unitTitleData[UNIT_BASE_PROGRESS] / speed;

    return progressPerSecond;
}

function GetUnitProgressSpeed(unitSaveData) {    
    var level = GetNumberFromProgress(UPGRADE_LEVEL, unitSaveData);
    var trainerLevel = GetNumberFromProgress(TRAINERS_ASSIGNED, unitSaveData);
    var speed = level + 1 - trainerLevel;
    speed = Math.max( speed, 1 );
    log.info("Getting unit progress speed: " + speed);

    return speed;
}

/////////////////////////////////////////////////
/// ~UnitCounting
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// TrainerAssignment
/// Related to assigning/unassigning trainers
/// to units.
/////////////////////////////////////////////////

handlers.initiateChangeInTraining = function (args) {
    var targetUnitID = args.data[TARGET_ID];
    var changeInTrainingLevel = parseInt(args.data[CHANGE], 10);

    log.info(targetUnitID);
    log.info("initiateChangeInTraining for " + targetUnitID + " by " + changeInTrainingLevel);

    var allProgressData = GetProgressData(CLASS_UNIT);
    var progressDataForUnit = GetProgressForTarget(allProgressData, targetUnitID);
    log.info("Progress data: " + JSON.stringify(progressDataForUnit));

    if (CanChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel)) {
        ChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel, targetUnitID, CLASS_UNIT)
    } else {
        return { outOfSync : true };
    }
}

function GetAvailableTrainers(allProgressData) {
    var totalTrainers = GetTotalTrainers();
    var trainersInUse = 0;

    for (var unitKey in allProgressData) {
        var unit = allProgressData[unitKey];
        trainersInUse += parseInt(unit[TRAINERS_ASSIGNED], 10);
    }
    
    var availableTrainers = totalTrainers - trainersInUse;
    log.info("Available Trainers: " + availableTrainers);
    return availableTrainers;
}

function GetTotalTrainers() {
    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var totalTrainers = 0;

    for (var trainerType in trainerCounts) {
        totalTrainers += trainerCounts[trainerType];
    }

    log.info("Total trainers: " + totalTrainers);
    return totalTrainers;   
}

function CanChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel) {
    var maxLevel = GetMaxTrainingLevel(progressDataForUnit);
    var changeResult = parseInt(progressDataForUnit[TRAINERS_ASSIGNED], 10) + changeInTrainingLevel;
    var availableTrainers = GetAvailableTrainers(allProgressData);

    var isChangeOK = false;
    if (changeInTrainingLevel < 0) {
        isChangeOK = changeResult >= 0;
    } else {
        isChangeOK = availableTrainers > 0 && changeResult <= maxLevel;
    }    

    log.info("Checking change against max level " + maxLevel + " with a changeResult " + changeResult);
    log.info("Can make change: " + isChangeOK);
    return isChangeOK;
}

function GetMaxTrainingLevel(progressDataForUnit) {
    return progressDataForUnit[UPGRADE_LEVEL];
}

function ChangeTrainingLevel(allProgressData, progressData, changeInTrainers, targetID, className) {
    UpdateCountDueToChangeInTraining(targetID, allProgressData);    

    var progressKey = GetProgressKey(className);
    var trainersAssigned = parseInt(progressData[TRAINERS_ASSIGNED], 10) + changeInTrainers;
    progressData[TRAINERS_ASSIGNED] = trainersAssigned;
    allProgressData[targetID] = progressData;    

    SetReadOnlyData(progressKey, allProgressData);
}

function UpdateCountDueToChangeInTraining(targetID, allProgressData) {
    var allUnitData = GetTitleDataForClass(CLASS_UNIT);
    var allBuildingProgress = GetProgressData(CLASS_BUILDING);
    var allBuildingData = GetTitleDataForClass(CLASS_BUILDING);

    UpdateCountForUnit(targetID, allProgressData, allUnitData, allBuildingProgress, allBuildingData, Date.now());
}

/////////////////////////////////////////////////
/// ~TrainerAssignment
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// TrainerPurchasing
/// Related to trainer purchasing.
/////////////////////////////////////////////////

/// The client calls this method to initiate a purchase of a normal trainer
handlers.initiateTrainerPurchase = function (args) {
    var playerInventory = GetPlayerInventory();
    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);

    if ( CanPurchaseTrainer(trainerSaveData, playerInventory) ) {
        PayForTrainer(trainerSaveData);

        AddTrainer(trainerSaveData);
    } else {
        return { outOfSync : true };
    }
}

function CanPurchaseTrainer(trainerSaveData, playerInventory) {
    var playerCurrencies = GetPlayerCurrenciesFromInventory(playerInventory);
    var cost = GetNextTrainerCost(trainerSaveData);

    var canPurchase = HasEnoughCurrency(playerCurrencies, CURRENCY_GOLD, cost);
    log.info("Can purchase new trainer: " + canPurchase);

    return canPurchase;
}

function GetNextTrainerCost(trainerSaveData) {
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var normalTrainers = trainerCounts[NORMAL_TRAINER];
    var cost = (normalTrainers + 1) * BASE_TRAINER_COST;

    log.info("Cost for a new normal trainer: " + cost);
    return cost;
}

function PayForTrainer(trainerSaveData) {
    var cost = GetNextTrainerCost(trainerSaveData);

    log.info("Paying for trainer: " + cost);

    server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: CURRENCY_GOLD, Amount: cost });
}

function AddTrainer(trainerSaveData) {
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    trainerCounts[NORMAL_TRAINER] += 1;

    SetReadOnlyData(TRAINER_SAVE_DATA, trainerSaveData);
}

/////////////////////////////////////////////////
/// ~TrainerPurchasing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Upgradeables
/// Methods the client can invoke related to an
/// upgradeable class.
/////////////////////////////////////////////////

/// The client calls this method to initiate an upgrade on a given upgradeable.
handlers.initiateUpgrade = function (args) {
    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var upgradeID = args.data[UPGRADE_ID];

    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var readOnlyData = GetProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);

    var playerInventory = GetPlayerInventory();

    if ( CanUpgrade(upgradeData, progressData, playerInventory) ) {
        PayForUpgrade(upgradeData, progressData, playerInventory);

        Upgrade(readOnlyData, className, progressData, targetID);
    } else {
        return { outOfSync : true };
    }
}

/// returns the upgrade data for a target ID, given a class name and upgrade ID
function GetUpgradeDataForTarget(className, targetID, upgradeID) {
    var dataForTarget = GetDataForTarget(className, targetID);
    var upgradeData = JSON.parse(dataForTarget[upgradeID]);

    return upgradeData;
}

/// checks to see if an upgrade can happen, given progress data for the target and the player's inventory
function CanUpgrade(upgradeData, progressData, playerInventory) {
    if (IsAtMaxLevel(upgradeData, progressData) || !CanAffordUpgrade(upgradeData, progressData, playerInventory)) {
        return false;
    }

    return true;
}

/// checks to see if an upgrade is at max level
function IsAtMaxLevel(upgradeData, progressData) {
    return progressData[UPGRADE_LEVEL] >= upgradeData["MaxLevel"];
}

/// checks to see if the player can afford an upgrade
function CanAffordUpgrade(upgradeData, progressData, playerInventory) {
    var playerCurrencies = GetPlayerCurrenciesFromInventory(playerInventory);
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];

    for (var resource in resourcesToUpgrade) {
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
        
        if(!HasEnoughCurrency(playerCurrencies, resource, cost)) {
            return false;
        }
    }

    return true;
}

/// deducts the cost of an upgrade from the player
function PayForUpgrade(upgradeData, progressData, playerInventory) {
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];    

    for (var resource in resourcesToUpgrade) {        
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
                
        server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: resource, Amount: cost });
    }
}

/// actually upgrades a target and saves it to the player's save data
function Upgrade(readOnlyData, className, progressData, targetID) {
    var progressKey = GetProgressKey(className);
    progressData[UPGRADE_LEVEL] += 1;
    readOnlyData[targetID] = progressData;    

    if (className == CLASS_UNIT) {
        ResetUnitCount(progressData);        
    }

    SetReadOnlyData(progressKey, readOnlyData);
}

/// given the resources to upgrade a target, a given resource, and the progress data for the target,
/// returns the cost in currency to upgrade that resource
function GetUpgradeCost(resourcesToUpgrade, resource, progressData) {
    var level = progressData[UPGRADE_LEVEL];
    var costPerLevel = resourcesToUpgrade[resource];
    var cost = costPerLevel * level;

    return cost;
}

/////////////////////////////////////////////////
/// ~Upgradeables
/////////////////////////////////////////////////