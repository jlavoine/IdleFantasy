/// NOTE: methods that start with handlers.(methodName) are methods accessible from the client.
/// All other methods are for the SERVER only!!! Do not change these lightly.
/// This file is clearly enormous. I've tried my best to "extract till I drop" and comment everything.
/// Because there are server API limits (10 per call), a lot of methods require the data structures from
/// the API calls to be passed in, so I don't wind up hitting the API a massive number of times.

/////////////////////////////////////////////////
/// Constants
/// Constants used in methods throughout the
/// cloud script.
/////////////////////////////////////////////////

/// game specific
const UPGRADE_LEVEL = "Level";  // key for a level upgrade
const CLASS = "Class";          // key used from client as to what type of data (building, unit, etc) is involved in the call
const TARGET_ID = "TargetID";   // key used from client as to what specific object is involved in the call
const CHANGE = "Change";        // key used from client to pass up a change

// currencies
const CURRENCY_GOLD = "G1";

// upgrade related
const UPGRADE_ID = "UpgradeID";                 // key used from client as to what upgradeable on the target is involed in the call
const UPGRADE_RESOURCES = "ResourcesToUpgrade"; // key for finding list of resources that an upgrade requires

// trainer related
const TRAINER_SAVE_DATA = "TrainerSaveData";    // key for player's trainer save data
const TRAINER_COUNTS = "TrainerCounts";         // key for trainer counts within the trainer save data object
const NORMAL_TRAINER = "Normal";                // the normal trainers a player can purchase
const TRAINERS_ASSIGNED = "Trainers";           // key in unit progress data for the # of trainers assigned to the unit
const BASE_TRAINER_COST = 1000;                 // base gold cost for a trainer

/// game modules
const MODULE_BASE = "Base";    // the base game!

/// classes of objects in the game
const CLASS_BUILDING = "Buildings";     // game buildings that produce units
const CLASS_UNIT = "Units";             // units that are apart of buildings

/// API specific
const VIRTUAL_CURRENCY = "VirtualCurrency"; // API key for virtual currency
const DATA = "Data";                        // API key for accessing data after getting the save data
const VALUE = "Value";                      // API key for accessing the actual data value after getting the save data

/////////////////////////////////////////////////
/// ~Constants
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Testing
/// These methods should all check that the
/// account is a testing account with isTesting().
/// These methods exist to edit save data and
/// currency in preperation for running very
/// specific integration tests.
/////////////////////////////////////////////////

/// Checks to see if the account is marked for testing.
function isTesting() {
    var internalData = server.GetUserInternalData({ PlayFabId: currentPlayerId, Keys: ["Testing"] });    
    var data = internalData[DATA];
    var value = data["Testing"];
    var isTesting = value[VALUE] == "true";
    
    log.info("Account Test Status: " + isTesting);

    return isTesting;
}

/// returns the progress data for a specific class and ID.
/// Used to check that a very specific portion of data changed.
handlers.getProgressData = function (args) {
    if (!isTesting) {
        return;    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];

    var readOnlyData = GetProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);
        
    var dataToString = JSON.stringify(progressData);
    var data = { data : dataToString };

    log.info("Returning progress data for " + targetID + "(" + className + "): " + data);

    return data;    
}

/// returns the normal trainer count of the player
handlers.getTrainerCount = function (args) {
    if (!isTesting) {
        return;    
    }

    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var normalTrainers = trainerCounts[NORMAL_TRAINER];

    var data = { data : normalTrainers };
    log.info("Returning trainer count data: " + data);

    return data;
}

/// sets player data of a key to a value
handlers.setPlayerData = function(args) {
    if (!isTesting) {
        return;
    }

    var key = args.data["Key"];
    var value = args.data[VALUE];

    var dataToSave = {};
    dataToSave[key] = value;

    log.info("Setting player data " + key + " to " + value);

    server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: dataToSave, Permission: "Public"});
}

/// sets a type of the player's currency to a value.
/// this has to be done by adding or subtracting the difference of
/// the incoming value depending on the player's current currency,
/// because there is no API call to set a currency to a specific value.
handlers.setPlayerCurrency = function(args) {
    if (!isTesting) {
        return;
    }

    var amountToSet = args.data["Amount"];
    var currencyType = args.data["Type"];

    var playerInventory = GetPlayerInventory();    
    var currentAmount = GetAmountOfCurrency(playerInventory, currencyType);
    var changeInCurrency = currentAmount - amountToSet;    

    log.info("Setting player currency(" + currencyType + ") to " + amountToSet);

    if (changeInCurrency > 0) {
        server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: changeInCurrency });
    } else if (changeInCurrency < 0) {
        server.AddUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: Math.abs(changeInCurrency) });
    }
}

/////////////////////////////////////////////////
/// ~Testing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Client data accessing
/// Methods the client can call to access data
/// that it can't normally access or change.
/////////////////////////////////////////////////

/// Returns all the title data for a particular class (buildings, units, etc)
handlers.getAllDataForClass = function (args) {
    var className = args.data[CLASS];

    var data = GetTitleDataForClass(className);

    return data;
}

function GetDataForTarget(className, targetID) {
    var allDataForClass = GetTitleDataForClass(className);
    var dataForTarget = allDataForClass[targetID];

    return dataForTarget;
}

function GetTitleDataForClass(className) {
    var moduleNames = GetAllModules();
    for (var i = 0; i < moduleNames.length; i++) {
        moduleNames[i] += className;
    }

    var titleData = server.GetTitleData({ Keys : moduleNames });
    var dataPerModule = titleData[DATA];
    var classData = {};

    for (var moduleKey in dataPerModule) {
        var classesInModule = JSON.parse(dataPerModule[moduleKey]);

        for(var data in classesInModule) {
            classData[data] = classesInModule[data];
        }
    }

    return classData;
}

/// returns all active modules are currently active in the game
function GetAllModules() {
    var modules = [MODULE_BASE];

    return modules;
}

/////////////////////////////////////////////////
/// ~Client data accessing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Misc
/// Misc methods that are used by many different
/// server methods.
/////////////////////////////////////////////////

function GetReadOnlySaveData(key) {
    var rawData = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId, Keys: [key] });
    var actualData = rawData[DATA];
    var data = actualData[key];
    var valueData = JSON.parse(data[VALUE]);

    log.info("Got read only save data: " + data[VALUE]);

    return valueData;  
}

function GetPlayerInventory() {
    var inventory = server.GetUserInventory({ PlayFabId: currentPlayerId });

    log.info("Getting player inventory: " + JSON.stringify(inventory));

    return inventory;
}

function HasEnoughCurrency(playerCurrencies, currencyType, amount) {
    var currentCurrency = playerCurrencies[currencyType];    
    return currentCurrency >= amount;
}

function GetAmountOfCurrency(playerInventory, currencyType) {
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];
    return playerCurrencies[currencyType];
}

function GetPlayerCurrenciesFromInventory(playerInventory) {    
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];

    return playerCurrencies;
}

/////////////////////////////////////////////////
/// ~Misc
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// ProgressData
/// Methods related to getting and changing 
/// progress data for a player.
/////////////////////////////////////////////////

/// returns actual progress data from the player's read only data
function GetProgressData(className) {
    var progressKey = GetProgressKey(className);
    var data = GetReadOnlySaveData(progressKey);

    return data;
}

/// returns the key for progress data based on a class name
function GetProgressKey(className) {
    return className + "Progress";
}

/// given read only data of all the progress data for a given class and a target ID,
/// returns the specific piece of progress data for the target
function GetProgressForTarget(readOnlyData, targetID) {    
    var progressData = readOnlyData[targetID];
    
    return progressData;
}

/////////////////////////////////////////////////
/// ~ProgressData
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// ~TrainerAssignment
/// Related to assigning/unassigning trainers
/// to units.
/////////////////////////////////////////////////

handlers.initiateChangeInTraining = function (args) {
    var targetUnitID = args.data[TARGET_ID];
    var changeInTrainingLevel = parseInt(args.data[CHANGE], 10);

    log.info(targetUnitID);
    log.info("initiateChangeInTraining for " + targetUnitID + " by " + changeInTrainingLevel);

    var allProgressData = GetProgressData(CLASS_UNIT);
    var progressDataForUnit = GetProgressForTarget(allProgressData, targetUnitID);
    log.info("Progress data: " + JSON.stringify(progressDataForUnit));

    if (CanChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel)) {
        ChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel, targetUnitID, CLASS_UNIT)
    } else {
        return { outOfSync : true };
    }
}

function GetAvailableTrainers(allProgressData) {
    var totalTrainers = GetTotalTrainers();
    var trainersInUse = 0;

    for (var unitKey in allProgressData) {
        var unit = allProgressData[unitKey];
        trainersInUse += unit[TRAINERS_ASSIGNED];
    }
    
    var availableTrainers = totalTrainers - trainersInUse;
    log.info("Available Trainers: " + availableTrainers);
    return availableTrainers;
}

function GetTotalTrainers() {
    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var totalTrainers = 0;

    for (var trainerType in trainerCounts) {
        totalTrainers += trainerCounts[trainerType];
    }

    log.info("Total trainers: " + totalTrainers);
    return totalTrainers;   
}

function CanChangeTrainingLevel(allProgressData, progressDataForUnit, changeInTrainingLevel) {
    var maxLevel = GetMaxTrainingLevel(progressDataForUnit);
    var changeResult = parseInt(progressDataForUnit[TRAINERS_ASSIGNED], 10) + changeInTrainingLevel;
    var availableTrainers = GetAvailableTrainers(allProgressData);

    var isChangeOK = false;
    if (changeInTrainingLevel < 0) {
        isChangeOK = changeResult >= 0;
    } else {
        isChangeOK = availableTrainers > 0 && changeResult <= maxLevel;
    }

    log.info("Checking change against max level " + maxLevel + " with a changeResult " + changeResult);
    log.info("Can make change: " + isChangeOK);
    return isChangeOK;
}

function GetMaxTrainingLevel(progressDataForUnit) {
    return progressDataForUnit[UPGRADE_LEVEL];
}

function ChangeTrainingLevel(allProgressData, progressData, changeInTrainers, targetID, className) {
    var trainersAssigned = parseInt(progressData[TRAINERS_ASSIGNED], 10) + changeInTrainers;
    progressData[TRAINERS_ASSIGNED] = trainersAssigned;
    allProgressData[targetID] = progressData;

    var dataAsString = JSON.stringify(allProgressData);

    var progressKey = GetProgressKey(className);
    log.info(progressKey);
    log.info(dataAsString);

    var data = {};
    data[progressKey] = dataAsString;
    log.info(data);

    server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: data, Permission: "Public"});
}

/////////////////////////////////////////////////
/// ~TrainerAssignment
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// TrainerPurchasing
/// Related to trainer purchasing.
/////////////////////////////////////////////////

/// The client calls this method to initiate a purchase of a normal trainer
handlers.initiateTrainerPurchase = function (args) {
    var playerInventory = GetPlayerInventory();
    var trainerSaveData = GetReadOnlySaveData(TRAINER_SAVE_DATA);

    if ( CanPurchaseTrainer(trainerSaveData, playerInventory) ) {
        PayForTrainer(trainerSaveData);

        AddTrainer(trainerSaveData);
    } else {
        return { outOfSync : true };
    }
}

function CanPurchaseTrainer(trainerSaveData, playerInventory) {
    var playerCurrencies = GetPlayerCurrenciesFromInventory(playerInventory);
    var cost = GetNextTrainerCost(trainerSaveData);

    var canPurchase = HasEnoughCurrency(playerCurrencies, CURRENCY_GOLD, cost);
    log.info("Can purchase new trainer: " + canPurchase);

    return canPurchase;
}

function GetNextTrainerCost(trainerSaveData) {
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    var normalTrainers = trainerCounts[NORMAL_TRAINER];
    var cost = (normalTrainers + 1) * BASE_TRAINER_COST;

    log.info("Cost for a new normal trainer: " + cost);
    return cost;
}

function PayForTrainer(trainerSaveData) {
    var cost = GetNextTrainerCost(trainerSaveData);

    log.info("Paying for trainer: " + cost);

    server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: CURRENCY_GOLD, Amount: cost });
}

function AddTrainer(trainerSaveData) {
    var trainerCounts = trainerSaveData[TRAINER_COUNTS];
    trainerCounts[NORMAL_TRAINER] += 1;

    var dataAsString = JSON.stringify(trainerSaveData);

    log.info("About to save new trainer data: " + dataAsString);

    var data = {};
    data[TRAINER_SAVE_DATA] = dataAsString;
    log.info(data);

    server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: data, Permission: "Public"});
}

/////////////////////////////////////////////////
/// ~TrainerPurchasing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Upgradeables
/// Methods the client can invoke related to an
/// upgradeable class.
/////////////////////////////////////////////////

/// The client calls this method to initiate an upgrade on a given upgradeable.
handlers.initiateUpgrade = function (args) {
    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var upgradeID = args.data[UPGRADE_ID];

    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var readOnlyData = GetProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);

    var playerInventory = GetPlayerInventory();

    if ( CanUpgrade(upgradeData, progressData, playerInventory) ) {
        PayForUpgrade(upgradeData, progressData, playerInventory);

        Upgrade(readOnlyData, className, progressData, targetID);
    } else {
        return { outOfSync : true };
    }
}

/// returns the upgrade data for a target ID, given a class name and upgrade ID
function GetUpgradeDataForTarget(className, targetID, upgradeID) {
    var dataForTarget = GetDataForTarget(className, targetID);
    var upgradeData = JSON.parse(dataForTarget[upgradeID]);

    return upgradeData;
}

/// checks to see if an upgrade can happen, given progress data for the target and the player's inventory
function CanUpgrade(upgradeData, progressData, playerInventory) {
    if (IsAtMaxLevel(upgradeData, progressData) || !CanAffordUpgrade(upgradeData, progressData, playerInventory)) {
        return false;
    }

    return true;
}

/// checks to see if an upgrade is at max level
function IsAtMaxLevel(upgradeData, progressData) {
    return progressData[UPGRADE_LEVEL] >= upgradeData["MaxLevel"];
}

/// checks to see if the player can afford an upgrade
function CanAffordUpgrade(upgradeData, progressData, playerInventory) {
    var playerCurrencies = GetPlayerCurrenciesFromInventory(playerInventory);
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];

    for (var resource in resourcesToUpgrade) {
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
        
        if(!HasEnoughCurrency(playerCurrencies, resource, cost)) {
            return false;
        }
    }

    return true;
}

/// deducts the cost of an upgrade from the player
function PayForUpgrade(upgradeData, progressData, playerInventory) {
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];    

    for (var resource in resourcesToUpgrade) {        
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
                
        server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: resource, Amount: cost });
    }
}

/// actually upgrades a target and saves it to the player's save data
function Upgrade(readOnlyData, className, progressData, targetID) {
    progressData[UPGRADE_LEVEL] += 1;
    readOnlyData[targetID] = progressData;

    var dataAsString = JSON.stringify(readOnlyData);

    var progressKey = GetProgressKey(className);
    log.info(progressKey);
    log.info(dataAsString);

    var data = {};
    data[progressKey] = dataAsString;
    log.info(data);

    server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: data, Permission: "Public"});
}

/// given the resources to upgrade a target, a given resource, and the progress data for the target,
/// returns the cost in currency to upgrade that resource
function GetUpgradeCost(resourcesToUpgrade, resource, progressData) {
    var level = progressData[UPGRADE_LEVEL];
    var costPerLevel = resourcesToUpgrade[resource];
    var cost = costPerLevel * level;

    return cost;
}

/////////////////////////////////////////////////
/// ~Upgradeables
/////////////////////////////////////////////////