/// NOTE: methods that start with handlers.(methodName) are methods accessible from the client.
/// All other methods are for the SERVER only!!! Do not change these lightly.
/// This file is clearly enormous. I've tried my best to "extract till I drop" and comment everything.
/// Because there are server API limits (10 per call), a lot of methods require the data structures from
/// the API calls to be passed in, so I don't wind up hitting the API a massive number of times.

/////////////////////////////////////////////////
/// Constants
/// Constants used in methods throughout the
/// cloud script.
/////////////////////////////////////////////////

/// game specific
const UPGRADE_LEVEL = "Level";  // key for a level upgrade
const CLASS = "Class";          // key used from client as to what type of data (building, unit, etc) is involved in the call
const TARGET_ID = "TargetID";   // key used from client as to what specific object is involved in the call

// upgrade related
const UPGRADE_ID = "UpgradeID";                 // key used from client as to what upgradeable on the target is involed in the call
const UPGRADE_RESOURCES = "ResourcesToUpgrade"; // key for finding list of resources that an upgrade requires

/// game modules
const MODULE_BASE = "Base";    // the base game!

/// classes of objects in the game
const BUILDING = "Building";    // game buildings that produce units

/// API specific
const VIRTUAL_CURRENCY = "VirtualCurrency"; // API key for virtual currency
const DATA = "Data";                        // API key for accessing data after getting the save data
const VALUE = "Value";                      // API key for accessing the actual data value after getting the save data

/////////////////////////////////////////////////
/// ~Constants
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Testing
/// These methods should all check that the
/// account is a testing account with isTesting().
/// These methods exist to edit save data and
/// currency in preperation for running very
/// specific integration tests.
/////////////////////////////////////////////////

/// Checks to see if the account is marked for testing.
function isTesting() {
    var internalData = server.GetUserInternalData({ PlayFabId: currentPlayerId, Keys: ["Testing"] });    
    var data = internalData[DATA];
    var value = data["Testing"];
    var isTesting = value[VALUE] == "true";
    
    log.info("Account Test Status: " + isTesting);

    return isTesting;
}

/// returns the progress data for a specific class and ID.
/// Used to check that a very specific portion of data changed.
handlers.getProgressData = function (args) {
    if (!isTesting) {
        return;    
    }

    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];

    var readOnlyData = GetReadOnlyProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);
        
    var dataToString = JSON.stringify(progressData);
    var data = { data : dataToString };

    log.info("Returning progress data for " + targetID + "(" + className + "): " + data);

    return data;    
}

/// sets player data of a key to a value
handlers.setPlayerData = function(args) {
    if (!isTesting) {
        return;
    }

    var key = args.data["Key"];
    var value = args.data[VALUE];

    var dataToSave = {};
    dataToSave[key] = value;

    log.info("Setting player data " + key + " to " + value);

    server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: dataToSave, Permission: "Public"});
}

/// sets a type of the player's currency to a value.
/// this has to be done by adding or subtracting the difference of
/// the incoming value depending on the player's current currency,
/// because there is no API call to set a currency to a specific value.
handlers.setPlayerCurrency = function(args) {
    if (!isTesting) {
        return;
    }

    var amountToSet = args.data["Amount"];
    var currencyType = args.data["Type"];

    var playerInventory = GetPlayerInventory();    
    var currentAmount = GetAmountOfCurrency(playerInventory, currencyType);
    var changeInCurrency = currentAmount - amountToSet;    

    log.info("Setting player currency(" + currencyType + ") to " + amountToSet);

    if (changeInCurrency > 0) {
        server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: changeInCurrency });
    } else if (changeInCurrency < 0) {
        server.AddUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: currencyType, Amount: Math.abs(changeInCurrency) });
    }
}

/////////////////////////////////////////////////
/// ~Testing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Client data accessing
/// Methods the client can call to access data
/// that it can't normally access or change.
/////////////////////////////////////////////////

/// Returns all the title data for a particular class (buildings, units, etc)
handlers.getAllDataForClass = function (args) {
    var className = args.data[CLASS];

    var data = GetTitleDataForClass(className);

    return data;
}

function GetDataForTarget(className, targetID) {
    var allDataForClass = GetTitleDataForClass(className);
    var dataForTarget = allDataForClass[targetID];

    return dataForTarget;
}

function GetTitleDataForClass(className) {
    var moduleNames = GetAllModules();
    for (var i = 0; i < moduleNames.length; i++) {
        moduleNames[i] += className;
    }

    var titleData = server.GetTitleData({ Keys : moduleNames });
    var dataPerModule = titleData[DATA];
    var classData = {};

    for (var moduleKey in dataPerModule) {
        var classesInModule = JSON.parse(dataPerModule[moduleKey]);

        for(var data in classesInModule) {
            classData[data] = classesInModule[data];
        }
    }

    return classData;
}

/// returns all active modules are currently active in the game
function GetAllModules() {
    var modules = [MODULE_BASE];

    return modules;
}

/////////////////////////////////////////////////
/// ~Client data accessing
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Misc
/// Misc methods that are used by many different
/// server methods.
/////////////////////////////////////////////////

function GetPlayerInventory() {
    return server.GetUserInventory({ PlayFabId: currentPlayerId });
}

function HasEnoughCurrency(playerCurrencies, currencyType, amount) {
    var currentCurrency = playerCurrencies[currencyType];    
    return currentCurrency >= amount;
}

function GetAmountOfCurrency(playerInventory, currencyType) {
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];
    return playerCurrencies[currencyType];
}

function GetPlayerCurrenciesFromInventory(playerInventory) {    
    var playerCurrencies = playerInventory[VIRTUAL_CURRENCY];

    return playerCurrencies;
}

/////////////////////////////////////////////////
/// ~Misc
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// ProgressData
/// Methods related to getting and changing 
/// progress data for a player.
/////////////////////////////////////////////////

/// returns actual progress data from the player's read only data
function GetReadOnlyProgressData(className) {
    var progressKey = GetProgressKey(className);
    var rawData = server.GetUserReadOnlyData({ PlayFabId: currentPlayerId, Keys: [progressKey] });
    var actualData = rawData[DATA];
    var data = actualData[progressKey];
    var valueData = JSON.parse(data[VALUE]);

    return valueData;    
}

/// returns the key for progress data based on a class name
function GetProgressKey(className) {
    return className + "Progress";
}

/// given read only data of all the progress data for a given class and a target ID,
/// returns the specific piece of progress data for the target
function GetProgressForTarget(readOnlyData, targetID) {    
    var progressData = readOnlyData[targetID];
    
    return progressData;
}

/////////////////////////////////////////////////
/// ~ProgressData
/////////////////////////////////////////////////

/////////////////////////////////////////////////
/// Upgradeables
/// Methods the client can invoke related to an
/// upgradeable class.
/////////////////////////////////////////////////

/// The client calls this method to initiate an upgrade on a given upgradeable.
handlers.initiateUpgrade = function (args) {
    var className = args.data[CLASS];
    var targetID = args.data[TARGET_ID];
    var upgradeID = args.data[UPGRADE_ID];

    var upgradeData = GetUpgradeDataForTarget(className, targetID, upgradeID);
    var readOnlyData = GetReadOnlyProgressData(className);
    var progressData = GetProgressForTarget(readOnlyData, targetID);

    var playerInventory = GetPlayerInventory();

    if ( CanUpgrade(upgradeData, progressData, playerInventory) ) {
        PayForUpgrade(upgradeData, progressData, playerInventory);

        Upgrade(readOnlyData, className, progressData, targetID);
    } else {
        return { outOfSync : true };
    }
}

/// returns the upgrade data for a target ID, given a class name and upgrade ID
function GetUpgradeDataForTarget(className, targetID, upgradeID) {
    var dataForTarget = GetDataForTarget(className, targetID);
    var upgradeData = JSON.parse(dataForTarget[upgradeID]);

    return upgradeData;
}

/// checks to see if an upgrade can happen, given progress data for the target and the player's inventory
function CanUpgrade(upgradeData, progressData, playerInventory) {
    if (IsAtMaxLevel(upgradeData, progressData) || !CanAffordUpgrade(upgradeData, progressData, playerInventory)) {
        return false;
    }

    return true;
}

/// checks to see if an upgrade is at max level
function IsAtMaxLevel(upgradeData, progressData) {
    return progressData[UPGRADE_LEVEL] >= upgradeData["MaxLevel"];
}

/// checks to see if the player can afford an upgrade
function CanAffordUpgrade(upgradeData, progressData, playerInventory) {
    var playerCurrencies = GetPlayerCurrenciesFromInventory(playerInventory);
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];

    for (var resource in resourcesToUpgrade) {
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
        
        if(!HasEnoughCurrency(playerCurrencies, resource, cost)) {
            return false;
        }
    }

    return true;
}

/// deducts the cost of an upgrade from the player
function PayForUpgrade(upgradeData, progressData, playerInventory) {
    var resourcesToUpgrade = upgradeData[UPGRADE_RESOURCES];    

    for (var resource in resourcesToUpgrade) {        
        var cost = GetUpgradeCost(resourcesToUpgrade, resource, progressData);
                
        server.SubtractUserVirtualCurrency({ PlayFabId: currentPlayerId, VirtualCurrency: resource, Amount: cost });
    }
}

/// actually upgrades a target and saves it to the player's save data
function Upgrade(readOnlyData, className, progressData, targetID) {
    progressData[UPGRADE_LEVEL] += 1;
    readOnlyData[targetID] = progressData;

    var dataAsString = JSON.stringify(readOnlyData);

    var progressKey = GetProgressKey(className);
    log.info(progressKey);
    log.info(dataAsString);

    var data = {};
    data[progressKey] = dataAsString;
    log.info(data);

    server.UpdateUserReadOnlyData({ PlayFabId: currentPlayerId, Data: data, Permission: "Public"});
}

/// given the resources to upgrade a target, a given resource, and the progress data for the target,
/// returns the cost in currency to upgrade that resource
function GetUpgradeCost(resourcesToUpgrade, resource, progressData) {
    var level = progressData[UPGRADE_LEVEL];
    var costPerLevel = resourcesToUpgrade[resource];
    var cost = costPerLevel * level;

    return cost;
}

/////////////////////////////////////////////////
/// ~Upgradeables
/////////////////////////////////////////////////